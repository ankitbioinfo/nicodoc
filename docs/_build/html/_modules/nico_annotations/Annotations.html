<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>nico_annotations.Annotations &mdash; NiCo 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=8d563738"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            NiCo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NiCo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">nico_annotations.Annotations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for nico_annotations.Annotations</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">gridspec</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="c1">#import pickle</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">SimpleNamespace</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">snn</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="n">fpath</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span><span class="s1">&#39;utils&#39;</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">SCTransform</span> <span class="kn">import</span> <span class="n">SCTransform</span>

<span class="c1">#warnings.filterwarnings(&#39;ignore&#39;)</span>
<span class="c1">#export PYTHONWARNINGS=&#39;ignore:Multiprocessing-backed parallel loops:UserWarning&#39;</span>
<span class="c1">#os.environ[&quot;PYTHONWARNINGS&quot;] = &quot;ignore::UserWarning&quot;</span>


<div class="viewcode-block" id="create_directory">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.create_directory">[docs]</a>
<span class="k">def</span> <span class="nf">create_directory</span><span class="p">(</span><span class="n">outputFolder</span><span class="p">):</span>
    <span class="s2">&quot;This function create empty directory.&quot;</span>
    <span class="n">answer</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outputFolder</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">answer</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">outputFolder</span><span class="p">)</span></div>



<div class="viewcode-block" id="find_index">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.find_index">[docs]</a>
<span class="k">def</span> <span class="nf">find_index</span><span class="p">(</span><span class="n">sp_genename</span><span class="p">,</span><span class="n">sc_genename</span><span class="p">):</span>
    <span class="s2">&quot;Helper function used in find_anchor_cells_between_ref_and_query to find the common gene space submatrix between two modalities.&quot;</span>
    <span class="n">index_sc</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">index_sp</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sc_genename</span><span class="p">)):</span>
        <span class="n">name</span><span class="o">=</span><span class="n">sc_genename</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">j</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp_genename</span><span class="p">)):</span>
        <span class="n">name</span><span class="o">=</span><span class="n">sp_genename</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">index_sc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">index_sp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index_sp</span><span class="p">,</span><span class="n">index_sc</span></div>



<div class="viewcode-block" id="find_match_index_in_dist">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.find_match_index_in_dist">[docs]</a>
<span class="k">def</span> <span class="nf">find_match_index_in_dist</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">index_1</span><span class="p">,</span><span class="n">index_2</span><span class="p">):</span>
    <span class="s2">&quot;The helper function used find_mutual_nn to find the correct pairing of cell barcodes.&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">index_1</span><span class="p">:</span>
            <span class="n">p1</span><span class="o">=</span><span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">index_2</span><span class="p">:</span>
            <span class="n">p2</span><span class="o">=</span><span class="n">t2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">,</span><span class="n">p2</span></div>



<div class="viewcode-block" id="find_mutual_nn">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.find_mutual_nn">[docs]</a>
<span class="k">def</span> <span class="nf">find_mutual_nn</span><span class="p">(</span><span class="n">minkowski_order</span><span class="p">,</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">sp_barcode</span><span class="p">,</span><span class="n">sc_barcode</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">):</span>
    <span class="s2">&quot;The helper function used in find_anchor_cells_between_ref_and_query to find mutual nearest neighbors using cKDTree.&quot;</span>
    <span class="c1">#data1 is spatial</span>
    <span class="c1">#data2 is single</span>

    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">d1</span><span class="p">,</span><span class="n">k_index_1</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">minkowski_order</span><span class="p">,</span><span class="n">workers</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="n">d2</span><span class="p">,</span><span class="n">k_index_2</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k2</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">minkowski_order</span><span class="p">,</span><span class="n">workers</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
    <span class="c1">#print(data1.shape,k_index_1.shape,&#39;\t&#39;,data2.shape, k_index_2.shape)</span>
    <span class="n">mutual_1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mutual_2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dist_1</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">dist_2</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
     <span class="n">t1</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">index_2</span><span class="p">]</span>
     <span class="n">s1</span><span class="o">=</span><span class="n">k_index_1</span><span class="p">[</span><span class="n">index_2</span><span class="p">]</span>
     <span class="k">for</span> <span class="n">index_1</span> <span class="ow">in</span> <span class="n">s1</span><span class="p">:</span>
        <span class="n">t2</span><span class="o">=</span><span class="n">d2</span><span class="p">[</span><span class="n">index_1</span><span class="p">]</span>
        <span class="n">s2</span><span class="o">=</span><span class="n">k_index_2</span><span class="p">[</span><span class="n">index_1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index_2</span> <span class="ow">in</span> <span class="n">s2</span><span class="p">:</span>
            <span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="o">=</span><span class="n">find_match_index_in_dist</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">index_1</span><span class="p">,</span><span class="n">index_2</span><span class="p">)</span>
            <span class="n">mutual_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_1</span><span class="p">)</span>
            <span class="n">mutual_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_2</span><span class="p">)</span>
            <span class="n">dist_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
            <span class="n">dist_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

    <span class="n">a1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mutual_1</span><span class="p">)</span>
    <span class="n">a2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mutual_2</span><span class="p">)</span>
    <span class="n">dist_1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_1</span><span class="p">)</span>
    <span class="n">dist_2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_2</span><span class="p">)</span>
    <span class="n">a1</span><span class="o">=</span><span class="n">sp_barcode</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span>
    <span class="n">a2</span><span class="o">=</span><span class="n">sc_barcode</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span>
    <span class="n">a1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a1</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="p">)))</span>
    <span class="n">a2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a2</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">a2</span><span class="p">)))</span>
    <span class="n">dist_1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dist_1</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_1</span><span class="p">)))</span>
    <span class="n">dist_2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dist_2</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_2</span><span class="p">)))</span>
    <span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">dist_1</span><span class="p">,</span><span class="n">dist_2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">b</span></div>





<div class="viewcode-block" id="sct_return_sc_sp_in_shared_common_PC_space">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.sct_return_sc_sp_in_shared_common_PC_space">[docs]</a>
<span class="k">def</span> <span class="nf">sct_return_sc_sp_in_shared_common_PC_space</span><span class="p">(</span><span class="n">ad_sp1</span><span class="p">,</span><span class="n">ad_sc1</span><span class="p">,</span><span class="n">no_of_pc</span><span class="p">,</span><span class="n">method</span><span class="p">):</span>
    <span class="s2">&quot;The helper function is used in find_anchor_cells_between_ref_and_query to transform the common gene expression data into PCA space.&quot;</span>
    <span class="n">sct_ad_sc</span><span class="o">=</span><span class="n">ad_sc1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sct_ad_sp</span><span class="o">=</span><span class="n">ad_sp1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">sct_ad_sp</span><span class="p">,</span> <span class="n">zero_center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">sct_ad_sc</span><span class="p">,</span> <span class="n">zero_center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">sct_ad_sc</span><span class="p">,</span><span class="n">zero_center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">n_comps</span><span class="o">=</span><span class="n">no_of_pc</span><span class="p">)</span>
    <span class="n">sc_com_pc</span><span class="o">=</span><span class="n">sct_ad_sc</span><span class="o">.</span><span class="n">varm</span><span class="p">[</span><span class="s1">&#39;PCs&#39;</span><span class="p">]</span>

    <span class="n">tp_sc</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sct_ad_sc</span><span class="o">.</span><span class="n">X</span><span class="p">))</span>
    <span class="n">tp_sp</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sct_ad_sp</span><span class="o">.</span><span class="n">X</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">tp_sc</span><span class="o">==</span><span class="s2">&quot;&lt;class &#39;scipy.sparse._csr.csr_matrix&#39;&gt;&quot;</span><span class="p">:</span>
        <span class="n">msc</span><span class="o">=</span><span class="n">sct_ad_sc</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msc</span><span class="o">=</span><span class="n">sct_ad_sc</span><span class="o">.</span><span class="n">X</span>

    <span class="k">if</span> <span class="n">tp_sp</span><span class="o">==</span><span class="s2">&quot;&lt;class &#39;scipy.sparse._csr.csr_matrix&#39;&gt;&quot;</span><span class="p">:</span>
        <span class="n">msp</span><span class="o">=</span><span class="n">sct_ad_sp</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msp</span><span class="o">=</span><span class="n">sct_ad_sp</span><span class="o">.</span><span class="n">X</span>


    <span class="n">msp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">msp</span><span class="p">)</span>
    <span class="n">msc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">msc</span><span class="p">)</span>
    <span class="n">transfer_sp_com</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">msp</span><span class="p">,</span> <span class="n">sc_com_pc</span><span class="p">)</span>
    <span class="n">transfer_sc_com</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">msc</span><span class="p">,</span> <span class="n">sc_com_pc</span><span class="p">)</span>




    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">transfer_sp_com</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">mu1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">transfer_sp_com</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">svd1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">transfer_sp_com</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">transfer_sp_com</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">transfer_sp_com</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">mu1</span><span class="p">)</span><span class="o">/</span><span class="n">svd1</span>

        <span class="n">mu2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">transfer_sc_com</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">svd2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">transfer_sc_com</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">transfer_sc_com</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">transfer_sc_com</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">mu2</span><span class="p">)</span><span class="o">/</span><span class="n">svd2</span>
        <span class="c1">#print(i,mu1,mu2,svd1,svd2)</span>



    <span class="n">sc_barcode</span><span class="o">=</span><span class="n">sct_ad_sc</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">sp_barcode</span><span class="o">=</span><span class="n">sct_ad_sp</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="c1">#print(&#39;sc&#39;,transfer_sc_com.shape,sc_cellname.shape)</span>
    <span class="c1">#print(&#39;sp&#39;,transfer_sp_com.shape,sp_cellname.shape)</span>

    <span class="k">return</span> <span class="n">transfer_sp_com</span><span class="p">,</span> <span class="n">transfer_sc_com</span><span class="p">,</span> <span class="n">sp_barcode</span><span class="p">,</span><span class="n">sc_barcode</span></div>






<div class="viewcode-block" id="find_annotation_index">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.find_annotation_index">[docs]</a>
<span class="k">def</span> <span class="nf">find_annotation_index</span><span class="p">(</span><span class="n">annot_cellname</span><span class="p">,</span><span class="n">sct_cellname</span><span class="p">):</span>
    <span class="s2">&quot;Helper function for find_commnon_MNN to find the correct cell name.&quot;</span>
    <span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">annot_cellname</span><span class="p">)):</span>
        <span class="n">d</span><span class="p">[</span><span class="n">annot_cellname</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span>

    <span class="n">index</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sct_cellname</span><span class="p">)):</span>
        <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">sct_cellname</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">index</span></div>





<div class="viewcode-block" id="find_commnon_MNN">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.find_commnon_MNN">[docs]</a>
<span class="k">def</span> <span class="nf">find_commnon_MNN</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The helper function is used in find_anchor_cells_between_ref_and_query to find the anchored cells between two modalities using the mutual nearest neighbors method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#df=pd.read_csv(input.fname_mnn_anchors,header=None)</span>
    <span class="c1">#data contains 2 column files of sct_pairing_shared_common_gene_PC.csv</span>
    <span class="c1"># first column is MNN pairs of spatial and</span>
    <span class="c1"># second column is MNN pairs of single cell</span>
    <span class="c1">#data=df.to_numpy()</span>
    <span class="n">data</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">fname_mnn_anchors</span>

    <span class="n">mnn_singlecell_matchpair_barcode_id</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mnn_spatial_matchpair_barcode_id</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># find the annotated indexes</span>
    <span class="n">index_annot_sc</span><span class="o">=</span><span class="n">find_annotation_index</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_barcode_id</span><span class="p">,</span><span class="n">mnn_singlecell_matchpair_barcode_id</span><span class="p">)</span>
    <span class="n">index_annot_sp</span><span class="o">=</span><span class="n">find_annotation_index</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_spatial_barcode_id</span><span class="p">,</span><span class="n">mnn_spatial_matchpair_barcode_id</span> <span class="p">)</span>



    <span class="c1">#There are many indexes for spatial and single cell data</span>
    <span class="c1"># 1) MNN single cell                    data[:,1]                                       90,876</span>
    <span class="c1"># 2) MNN unique                          mnn_singlecell_matchpair_id                    10,089</span>
    <span class="c1"># 3) SC transform cell id                input.sct_singlecell_barcode_id                18,754</span>
    <span class="c1"># 4) original matrix cell id             input.annotation_singlecell_barcode_id         185,894</span>
    <span class="c1"># 5) original cell type name            input.annotation_singlecell_celltypename        185,894</span>
    <span class="c1"># 6) MNN unique id in sct               mnn_singlecell_matchpair_barcode_id             10,089</span>
    <span class="c1"># 7) common index between 6 and 4       index_mnn_sc,index_annot_sc</span>

    <span class="c1"># 1) MNN spatial                        data[:,0]                                       90,876</span>
    <span class="c1"># 2) MNN unique                         mnn_spatial_matchpair_id                        8,932</span>
    <span class="c1"># 3) SC transform cell id               input.sct_spatial_barcode_id                    86,880</span>
    <span class="c1"># 4) original matrix cell id            input.annotation_spatial_barcode_id             395,215</span>
    <span class="c1"># 5) original cell type name            input.annotation_spatial_celltypename           395,215</span>
    <span class="c1"># 55) original spatial cluster id       input.annotation_spatial_cluster_id             395,215</span>
    <span class="c1"># 6) MNN unique id in sct               mnn_spatial_matchpair_barcode_id                8,932</span>
    <span class="c1"># 7) common index between 6 and 4       index_mnn_sp,index_annot_sp</span>

    <span class="n">d_single_cluster</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">singlecell_unique_clusterid</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">d_single_cluster</span><span class="p">[</span><span class="n">singlecell_unique_clusterid</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>

    <span class="n">d_spatial_cluster</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">spatialcell_unique_clusterid</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">d_spatial_cluster</span><span class="p">[</span><span class="n">spatialcell_unique_clusterid</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>

    <span class="n">total_in_row</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">total_in_col</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">d_single</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_cluster_id</span><span class="p">)):</span>
        <span class="n">d_single</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_barcode_id</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_cluster_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">col</span><span class="o">=</span><span class="n">d_single_cluster</span><span class="p">[</span><span class="n">d_single</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_barcode_id</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
        <span class="n">total_in_col</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">col</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

    <span class="n">d_spatial</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_spatial_cluster_id</span><span class="p">)):</span>
        <span class="n">d_spatial</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_spatial_barcode_id</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_spatial_cluster_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">spatialcell_cluid</span><span class="o">=</span><span class="n">d_spatial</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_spatial_barcode_id</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">col</span><span class="o">=</span><span class="n">d_spatial_cluster</span><span class="p">[</span><span class="n">spatialcell_cluid</span><span class="p">]</span>
        <span class="n">total_in_row</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">col</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>


    <span class="n">mat21</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">mat22</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">mat1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span> <span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">mat3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>


    <span class="n">unique_singlecell_barcode_in_MNN</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_singlecell_barcode_in_MNN</span><span class="p">)):</span>
        <span class="n">singlecell_cluid</span><span class="o">=</span><span class="n">d_single</span><span class="p">[</span><span class="n">unique_singlecell_barcode_in_MNN</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">col</span><span class="o">=</span><span class="n">d_single_cluster</span><span class="p">[</span><span class="n">singlecell_cluid</span><span class="p">]</span>
        <span class="c1">#print(i,spatialcell_cluid)</span>
        <span class="n">mat1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">col</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>


    <span class="c1">#count how many anchor points matches to each spatial clusters</span>
    <span class="n">unique_spatial_barcode_in_MNN</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_spatial_barcode_in_MNN</span><span class="p">)):</span>
        <span class="n">spatialcell_cluid</span><span class="o">=</span><span class="n">d_spatial</span><span class="p">[</span><span class="n">unique_spatial_barcode_in_MNN</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">col</span><span class="o">=</span><span class="n">d_spatial_cluster</span><span class="p">[</span><span class="n">spatialcell_cluid</span><span class="p">]</span>
        <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">col</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>


    <span class="n">anchorFreqRow</span><span class="o">=</span><span class="n">mat3</span><span class="o">/</span><span class="n">total_in_row</span>
    <span class="n">anchorFreqCol</span><span class="o">=</span><span class="n">mat1</span><span class="o">/</span><span class="n">total_in_col</span>

    <span class="n">save_anchors</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="n">spatialcell_cluid</span><span class="o">=</span><span class="n">d_spatial</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">singlecell_cluid</span><span class="o">=</span><span class="n">d_single</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">col</span><span class="o">=</span><span class="n">d_spatial_cluster</span><span class="p">[</span><span class="n">spatialcell_cluid</span><span class="p">]</span>
            <span class="n">row</span><span class="o">=</span><span class="n">d_single_cluster</span><span class="p">[</span><span class="n">singlecell_cluid</span><span class="p">]</span>
            <span class="n">mat21</span><span class="p">[</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">mat22</span><span class="p">[</span><span class="n">col</span><span class="p">,</span><span class="n">row</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;#&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;#&#39;</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">save_anchors</span><span class="p">:</span>
                <span class="n">save_anchors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">save_anchors</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">save_anchors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="c1">#col normalization</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat21</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">mat21</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">mat21</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mat21</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat22</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">mat22</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">mat22</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mat22</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>


    <span class="n">newmat2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">anchorFreqCol</span><span class="p">,</span><span class="n">mat22</span><span class="p">))</span>
    <span class="n">mat2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">anchorFreqRow</span><span class="p">,</span><span class="n">mat21</span><span class="p">))</span>
    <span class="n">cname2</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">newcname2</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


    <span class="c1">#fw=open(input.savepath+&quot;spatial_annotation_along_SP.dat&quot;,&#39;w&#39;)</span>
    <span class="n">unique_rep_of_leiden_clusters_in_sp</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">af</span><span class="o">=</span><span class="n">mat2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
        <span class="n">col</span><span class="o">=</span><span class="n">mat2</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="n">i</span><span class="p">]</span>
        <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">col</span><span class="p">)</span>
        <span class="n">found</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)):</span>
            <span class="n">value</span><span class="o">=</span><span class="n">col</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">nct</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">&gt;</span><span class="nb">input</span><span class="o">.</span><span class="n">across_spatial_clusters_dispersion_cutoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">found</span><span class="o">+=</span><span class="s1">&#39;, &#39;</span>
                <span class="n">found</span><span class="o">+=</span><span class="n">nct</span><span class="o">+</span><span class="s1">&#39;:&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">%0.3f</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">value</span>
                <span class="k">if</span> <span class="n">cname2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_rep_of_leiden_clusters_in_sp</span><span class="p">:</span>
                    <span class="n">unique_rep_of_leiden_clusters_in_sp</span><span class="p">[</span><span class="n">cname2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="p">[</span><span class="n">nct</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nct</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_rep_of_leiden_clusters_in_sp</span><span class="p">[</span><span class="n">cname2</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                        <span class="n">unique_rep_of_leiden_clusters_in_sp</span><span class="p">[</span><span class="n">cname2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nct</span><span class="p">)</span>
        <span class="c1">#fw.write(str(i)+&#39;\t&#39;+cname2[i]+&#39;\tF=&#39;+str(&#39;%0.3f&#39;%af)+&#39;,\t&#39;+found+&#39;\n&#39;)</span>

    <span class="c1">#these clusters should not be removed</span>
    <span class="n">low_anchors_spatial_clusters</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">unique_rep_of_leiden_clusters_in_sp</span><span class="p">:</span>
        <span class="n">temp</span><span class="o">=</span><span class="n">unique_rep_of_leiden_clusters_in_sp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">low_anc_ct</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">low_anc_ct</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">low_anchors_spatial_clusters</span><span class="p">:</span>
                <span class="n">low_anchors_spatial_clusters</span><span class="p">[</span><span class="n">low_anc_ct</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">low_anchors_spatial_clusters</span><span class="p">[</span><span class="n">low_anc_ct</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c1">#print(&quot;low anchors&quot;,low_anchors_spatial_clusters)</span>
    <span class="c1">#{&#39;KCs&#39;: [&#39;c11&#39;, &#39;c7&#39;], &#39;Stellatecells&#39;: [&#39;c12&#39;], &#39;Cholangiocytes&#39;: [&#39;c16&#39;], &#39;Bcells&#39;: [&#39;c17&#39;], &#39;LSECs&#39;: [&#39;c18&#39;, &#39;c6&#39;]}</span>


    <span class="c1">#fw.close()</span>
    <span class="c1">#fw=open(input.savepath+&quot;spatial_annotation_along_SC.dat&quot;,&#39;w&#39;)</span>
    <span class="n">good_anchors</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">tt</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">newmat2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">af</span><span class="o">=</span><span class="n">newmat2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
        <span class="n">col</span><span class="o">=</span><span class="n">newmat2</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="n">i</span><span class="p">]</span>
        <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">col</span><span class="p">)</span>
        <span class="n">found</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)):</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">if</span> <span class="n">col</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">&gt;</span><span class="nb">input</span><span class="o">.</span><span class="n">across_spatial_clusters_dispersion_cutoff</span><span class="p">:</span>
                <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
                <span class="c1"># this flag is true if spillovered anchores belong to other leiden cluster are &gt; dispersion cutoff</span>
            <span class="k">elif</span> <span class="n">newcname2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">low_anchors_spatial_clusters</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="ow">in</span> <span class="n">low_anchors_spatial_clusters</span><span class="p">[</span><span class="n">newcname2</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
                <span class="c1"># this flag is true if spillovered anchores belong to other leiden cluster &lt; dispersion but uniquly mapped</span>

            <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">found</span><span class="o">+=</span><span class="s1">&#39;, &#39;</span>
                <span class="n">found</span><span class="o">+=</span><span class="nb">input</span><span class="o">.</span><span class="n">lsp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">+</span><span class="s1">&#39;:&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">%0.3f</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">col</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>

                <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;#&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">tt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">save_anchors</span><span class="p">:</span>
                    <span class="n">list_of_anchors</span><span class="o">=</span><span class="n">save_anchors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_anchors</span><span class="p">)):</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">list_of_anchors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="c1">#print(name)</span>
                        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">good_anchors</span><span class="p">:</span>
                            <span class="n">good_anchors</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">good_anchors</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>

        <span class="c1">#fw.write(str(i)+&#39;\t&#39;+newcname2[i]+&#39;\tF=&#39;+str(&#39;%0.3f&#39;%af)+&#39;,\t&#39;+found+&#39;\n&#39;)</span>
    <span class="c1">#fw.close()</span>

    <span class="n">c</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">good_anchors</span><span class="p">:</span>
        <span class="n">c</span><span class="o">+=</span><span class="n">good_anchors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">ca</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">save_anchors</span><span class="p">:</span>
        <span class="n">list_of_anchors</span><span class="o">=</span><span class="n">save_anchors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">count</span><span class="o">+=</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_anchors</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_anchors</span><span class="p">)):</span>
            <span class="n">ca</span><span class="p">[</span><span class="n">list_of_anchors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span>

    <span class="n">colname</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total # of sc&#39;</span><span class="p">,</span> <span class="s1">&#39;total # of sp&#39;</span><span class="p">]</span>
    <span class="n">cname1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;anchorFreq&#39;</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">visualize</span><span class="o">=</span><span class="p">[</span><span class="n">mat2</span><span class="p">,</span><span class="n">cname1</span><span class="p">,</span><span class="n">cname2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">good_anchors</span><span class="p">,</span><span class="n">visualize</span></div>



<div class="viewcode-block" id="visualize_spatial_anchored_cell_mapped_to_scRNAseq">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.visualize_spatial_anchored_cell_mapped_to_scRNAseq">[docs]</a>
<span class="k">def</span> <span class="nf">visualize_spatial_anchored_cell_mapped_to_scRNAseq</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">10</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function visualizes the anchored cells mapping between two modalities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat2</span><span class="p">,</span><span class="n">cname1</span><span class="p">,</span><span class="n">cname2</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">visualize_anchors</span>
    <span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">snn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mat2</span><span class="p">,</span><span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;0.2f&#39;</span><span class="p">,</span><span class="n">xticklabels</span><span class="o">=</span><span class="n">cname2</span><span class="p">,</span> <span class="n">annot_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span><span class="n">yticklabels</span><span class="o">=</span><span class="n">cname1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Spatial Leiden Clusters&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;scRNAseq Clusters&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;MNN K = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">KNN</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">savepath</span><span class="o">+</span><span class="s1">&#39;visualize_anchors.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">savepath</span><span class="o">+</span><span class="s1">&#39;visualize_anchors.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>






<div class="viewcode-block" id="find_anchor_cells_between_ref_and_query">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.find_anchor_cells_between_ref_and_query">[docs]</a>
<span class="k">def</span> <span class="nf">find_anchor_cells_between_ref_and_query</span><span class="p">(</span><span class="n">refpath</span><span class="o">=</span><span class="s1">&#39;./inputRef/&#39;</span><span class="p">,</span><span class="n">quepath</span><span class="o">=</span><span class="s1">&#39;./inputQuery/&#39;</span><span class="p">,</span><span class="n">neigh</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">no_of_pc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">minkowski_order</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **This function find all the anchored cells between queried and reference data.**</span>

<span class="sd">    Inputs:</span>

<span class="sd">    | Reference path for scRNAseq. This directory should contain originial count matrix (&#39;Original_counts.h5ad&#39;), and scTransform-like normalization matrix in the common gene space (&#39;sct_singleCell.h5ad&#39;).</span>
<span class="sd">    | (default) refpath=&#39;./inputRef/&#39;</span>

<span class="sd">    | Queried path for single cell resolution of spatial data. This directory contains an expression matrix in scTransform-like normalization in the common gene space (&#39;sct_spatial.h5ad&#39;).</span>
<span class="sd">    | (default) quepath=&#39;./inputQuery/&#39;</span>

<span class="sd">    | The K-nearest neighbor to find the anchored cells</span>
<span class="sd">    | (default) neigh=50</span>

<span class="sd">    | The number of principal components used to transform normalized expression matrix into PCA space.</span>
<span class="sd">    | This PCA-transformed matrix will be used to find the mutual nearest neighbor using the nearest neighbor distance.</span>
<span class="sd">    | (default) no_of_pc=50</span>

<span class="sd">    | Type of distance matrix: 2 means Euclidean distance, 1 means Manhattan distance</span>
<span class="sd">    | (default) minkowski_order=2</span>


<span class="sd">    Outputs:</span>

<span class="sd">    | The output contains the mapping cell information between two modalities.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ref_h5ad</span><span class="o">=</span><span class="n">refpath</span><span class="o">+</span><span class="s1">&#39;sct_singleCell.h5ad&#39;</span>
    <span class="n">que_h5ad</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;sct_spatial.h5ad&#39;</span>
    <span class="c1">#delimiter=&#39;,&#39;</span>
    <span class="n">sct_ad_sp</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">que_h5ad</span><span class="p">)</span>
    <span class="n">sct_ad_sc</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">ref_h5ad</span><span class="p">)</span>

    <span class="n">original_h5ad</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">refpath</span><span class="o">+</span><span class="s1">&#39;Original_counts.h5ad&#39;</span><span class="p">)</span>

    <span class="c1">#cellname=np.reshape(cellname,(len(cellname),1))</span>
    <span class="c1">#annotation_singlecell_celltypename=np.reshape(annotation_singlecell_celltypename,(len(annotation_singlecell_celltypename),1))</span>

    <span class="n">outputFolder</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span>
    <span class="n">create_directory</span><span class="p">(</span><span class="n">outputFolder</span><span class="p">)</span>
    <span class="c1">#method=&#39;gauss&#39;</span>
    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;umap&#39;</span>
    <span class="n">adata_query</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">que_h5ad</span><span class="p">)</span>

    <span class="n">sp_genename</span><span class="o">=</span><span class="n">sct_ad_sp</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">sc_genename</span><span class="o">=</span><span class="n">sct_ad_sc</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">index_sp</span><span class="p">,</span><span class="n">index_sc</span><span class="o">=</span><span class="n">find_index</span><span class="p">(</span><span class="n">sp_genename</span><span class="p">,</span><span class="n">sc_genename</span><span class="p">)</span>

    <span class="n">ad_sp_ori</span><span class="o">=</span><span class="n">sct_ad_sp</span><span class="p">[:,</span><span class="n">index_sp</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ad_sc_ori</span><span class="o">=</span><span class="n">sct_ad_sc</span><span class="p">[:,</span><span class="n">index_sc</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">ad_sc_ori</span><span class="o">.</span><span class="n">write_h5ad</span><span class="p">(</span><span class="n">outputFolder</span><span class="o">+</span><span class="s1">&#39;final_sct_sc.h5ad&#39;</span><span class="p">)</span>
    <span class="n">ad_sp_ori</span><span class="o">.</span><span class="n">write_h5ad</span><span class="p">(</span><span class="n">outputFolder</span><span class="o">+</span><span class="s1">&#39;final_sct_sp.h5ad&#39;</span><span class="p">)</span>

    <span class="n">fmnn</span><span class="o">=</span><span class="n">outputFolder</span><span class="o">+</span><span class="s2">&quot;anchors_data_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.npz&#39;</span>

    <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fmnn</span><span class="p">):</span>
        <span class="n">filesize</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">fmnn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filesize</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
    <span class="c1">#if flag==1:</span>
    <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">input_sp</span><span class="p">,</span><span class="n">input_sc</span><span class="p">,</span><span class="n">sp_barcode</span><span class="p">,</span><span class="n">sc_barcode</span><span class="o">=</span><span class="n">sct_return_sc_sp_in_shared_common_PC_space</span><span class="p">(</span><span class="n">ad_sp_ori</span><span class="p">,</span><span class="n">ad_sc_ori</span><span class="p">,</span><span class="n">no_of_pc</span><span class="p">,</span><span class="n">method</span><span class="p">)</span>
        <span class="c1">#print(&#39;sp&#39;,input_sp.shape,&#39;\nsc&#39;,input_sc.shape)</span>
        <span class="n">corrected</span> <span class="o">=</span> <span class="n">find_mutual_nn</span><span class="p">(</span><span class="n">minkowski_order</span><span class="p">,</span><span class="n">input_sp</span><span class="p">,</span><span class="n">input_sc</span><span class="p">,</span><span class="n">sp_barcode</span><span class="p">,</span><span class="n">sc_barcode</span><span class="p">,</span> <span class="n">k1</span><span class="o">=</span> <span class="n">neigh</span><span class="p">,</span><span class="n">k2</span><span class="o">=</span> <span class="n">neigh</span><span class="p">)</span>
        <span class="c1">#pd.DataFrame(corrected).to_csv(fmnn,index=False,header=None)</span>
        <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">k_dist</span><span class="p">,</span><span class="n">k_index</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">input_sp</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">input_sp</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">neigh</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">minkowski_order</span><span class="p">,</span><span class="n">workers</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">knn_neigh</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k_index</span><span class="p">)):</span>
            <span class="n">t</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k_index</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">k_index</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_barcode</span><span class="p">[</span><span class="nb">id</span><span class="p">])</span>
            <span class="n">knn_neigh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">knn_neigh</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">knn_neigh</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">fmnn</span><span class="p">,</span><span class="n">anchors</span><span class="o">=</span><span class="n">corrected</span><span class="p">,</span><span class="n">k_dist</span><span class="o">=</span><span class="n">k_dist</span><span class="p">,</span><span class="n">k_index</span><span class="o">=</span><span class="n">knn_neigh</span><span class="p">)</span>

        <span class="n">inputvar</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;savepath&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">outputFolder</span>
        <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;KNN&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">neigh</span>
        <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;ad_sp&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ad_sp_ori</span>
        <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;original_h5ad&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">original_h5ad</span>
        <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;adata_query&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">adata_query</span>
        <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;fmnn&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">fmnn</span>
        <span class="n">outputvar</span><span class="o">=</span><span class="n">SimpleNamespace</span><span class="p">(</span><span class="o">**</span><span class="n">inputvar</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">outputvar</span></div>


<div class="viewcode-block" id="delete_files">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.delete_files">[docs]</a>
<span class="k">def</span> <span class="nf">delete_files</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="s2">&quot;This function will delete the anchors file and temporary file generated during the annotations.&quot;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">savepath</span><span class="o">+</span><span class="s1">&#39;final_sct_sc.h5ad&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">savepath</span><span class="o">+</span><span class="s1">&#39;final_sct_sp.h5ad&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">fmnn</span><span class="p">)</span></div>



<div class="viewcode-block" id="nico_based_annotation">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.nico_based_annotation">[docs]</a>
<span class="k">def</span> <span class="nf">nico_based_annotation</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span><span class="n">ref_cluster_tag</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span><span class="n">across_spatial_clusters_dispersion_cutoff</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span><span class="n">guiding_spatial_cluster_resolution_tag</span><span class="o">=</span><span class="s1">&#39;leiden0.5&#39;</span><span class="p">,</span>
<span class="n">number_of_iteration_to_perform_celltype_annotations</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">resolved_tie_issue_with_weighted_nearest_neighbor</span><span class="o">=</span><span class="s1">&#39;No&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    | **This is the primary function called by the user to perform the NiCo-based annotation in the spatial cells using the label transfer from scRNAseq data. The scRNAseq must have cell type information in the .obs[cluster] tag.**</span>
<span class="sd">    | **This function finds the spatial cell type annotations based on the anchored cells. It chose the method either with the majority vote or weighted nearest distance from the spatial cell neighbors.**</span>

<span class="sd">    | First, it reads the output of find_anchor_cells_between_ref_and_query, and then annotates based on the input arguments.</span>

<span class="sd">    Inputs:</span>

<span class="sd">    The main input (previous) is the output from find_anchor_cells_between_ref_and_query.</span>

<span class="sd">    | The tag in reference h5ad file (Original_counts.h5ad) where cluster information is stored</span>
<span class="sd">    | (default) ref_cluster_tag=&#39;cluster&#39;</span>

<span class="sd">    | The guiding spatial Leiden cluster resolution, i.e., different resolution parameters of the Leiden cluster, should be stored in the queried file.</span>
<span class="sd">    | (default) guiding_spatial_cluster_resolution_tag=&#39;leiden0.5&#39;</span>
<span class="sd">    | sct_spatial.h5ad file should have a different resolution of Leiden clustering to guide the NiCo annotation.</span>
<span class="sd">    | It is good to have several Leiden clustering resolutions 0.3, 0.4, 0.5, 0.6, 0.7 and 0.8 that can be tagged with &#39;leiden0.3&#39;, &#39;leiden0.4&#39;, &#39;leiden0.5&#39;, &#39;leiden0.6&#39;, &#39;leiden0.7&#39; and &#39;leiden0.8&#39; in the adata.obs[].</span>


<span class="sd">    | The cutoff used to remove the noisy anchors if anchored cells belong to any guiding spatial cluster with less than 0.15 % of the population</span>
<span class="sd">    | (default) across_spatial_clusters_dispersion_cutoff=0.15</span>

<span class="sd">    | The number of iterations to perform the annotations</span>
<span class="sd">    | (default) number_of_iteration_to_perform_celltype_annotations=3</span>


<span class="sd">    | Non-anchored cell uses their neighbors to find the proportion of cell types. The cell type having the highest proportion is assigned to this non-anchored cell.</span>
<span class="sd">    | If the proportion occurs in a tie between two cell types, then &#39;No&#39; statement is assigned to &#39;NM&#39; (not mapped);</span>
<span class="sd">    | otherwise, the &#39;Yes&#39; statement uses the scheme inversely proportional to the distance</span>
<span class="sd">    | to find the cell type that has the best weighted average score.</span>
<span class="sd">    | (default) resolved_tie_issue_with_weighted_nearest_neighbor=&#39;No&#39;</span>


<span class="sd">    Outputs:</span>

<span class="sd">    | For each iteration, the annotation cluster file (_nico_annotation_cluster.csv) and cluster cell type name file (_nico_annotation_ct_name.csv) will be generated in the following directory.</span>
<span class="sd">    | (default) ./inputQuery/MNN_based_annotations/</span>
<span class="sd">    | To find the niche cell type interactions in the spatial_neighborhood_analysis, we used the final iteration of the annotation.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">df</span><span class="o">=</span><span class="n">previous</span><span class="o">.</span><span class="n">original_h5ad</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">ref_cluster_tag</span><span class="p">]</span>
    <span class="n">annotation_singlecell_celltypename</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">cellname</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="n">ad_sc_ori</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">previous</span><span class="o">.</span><span class="n">savepath</span><span class="o">+</span><span class="s1">&#39;final_sct_sc.h5ad&#39;</span><span class="p">)</span>
    <span class="n">ad_sp_ori</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">previous</span><span class="o">.</span><span class="n">savepath</span><span class="o">+</span><span class="s1">&#39;final_sct_sp.h5ad&#39;</span><span class="p">)</span>
    <span class="n">singlecell_sct_barcode_id</span><span class="o">=</span><span class="n">ad_sc_ori</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">spatialcell_sct_barcode_id</span><span class="o">=</span><span class="n">ad_sp_ori</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="n">sc_ct_name</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">A</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">annotation_singlecell_celltypename</span><span class="p">)))</span>
    <span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
        <span class="n">sc_ct_name</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">d</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span>
    <span class="n">sc_ct_name</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sc_ct_name</span><span class="p">)</span>
    <span class="c1">#sc_cluster=np.hstack((cellname,annotation_singlecell_celltypename))</span>
    <span class="n">sc_cluster</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">annotation_singlecell_celltypename</span><span class="p">)):</span>
        <span class="n">sc_cluster</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cellname</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">annotation_singlecell_celltypename</span><span class="p">[</span><span class="n">j</span><span class="p">]]])</span>
    <span class="n">sc_cluster</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sc_cluster</span><span class="p">)</span>
    <span class="n">annotation_singlecell_barcode_id</span><span class="o">=</span><span class="n">sc_cluster</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">annotation_singlecell_cluster_id</span><span class="o">=</span><span class="n">sc_cluster</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">singlecell_unique_clustername</span><span class="o">=</span><span class="n">sc_ct_name</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">singlecell_unique_clusterid</span><span class="o">=</span><span class="n">sc_ct_name</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>


    <span class="n">df</span><span class="o">=</span><span class="n">previous</span><span class="o">.</span><span class="n">adata_query</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">guiding_spatial_cluster_resolution_tag</span><span class="p">]</span><span class="c1">#.to_csv(spatialclusterFilename,header=True)</span>
    <span class="n">annotation_spatial_barcode_id</span><span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">annotation_spatial_cluster_id</span><span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">spatialcell_unique_clustername</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">spatialcell_unique_clusterid</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">annotation_spatial_cluster_id</span><span class="p">)))</span>
    <span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spatialcell_unique_clusterid</span><span class="p">)):</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">spatialcell_unique_clusterid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">d</span><span class="p">[</span><span class="n">spatialcell_unique_clusterid</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">name</span>
        <span class="n">spatialcell_unique_clustername</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">annotation_spatial_celltypename</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">annotation_spatial_cluster_id</span><span class="p">)):</span>
        <span class="n">annotation_spatial_celltypename</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">annotation_spatial_cluster_id</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="n">annotation_spatial_celltypename</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">annotation_spatial_celltypename</span><span class="p">)</span>
    <span class="n">spatialcell_unique_clustername</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spatialcell_unique_clustername</span><span class="p">)</span>



    <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">previous</span><span class="o">.</span><span class="n">fmnn</span><span class="p">,</span><span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">spatial_annotation_output_fname</span><span class="o">=</span><span class="s1">&#39;nico_annotation&#39;</span>
    <span class="n">spatial_deg_annotation_output_clustername</span><span class="o">=</span><span class="n">spatial_annotation_output_fname</span><span class="o">+</span><span class="s1">&#39;_cluster.csv&#39;</span>
    <span class="n">spatial_deg_annotation_output_celltypename</span><span class="o">=</span><span class="n">spatial_annotation_output_fname</span><span class="o">+</span><span class="s1">&#39;_ct_name.csv&#39;</span>

    <span class="n">inputvar</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;fname_mnn_anchors&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;anchors&#39;</span><span class="p">]</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;annotation_singlecell_barcode_id&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">annotation_singlecell_barcode_id</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;annotation_singlecell_celltypename&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">annotation_singlecell_celltypename</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;annotation_singlecell_cluster_id&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">annotation_singlecell_cluster_id</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;lsc&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">singlecell_unique_clustername</span><span class="p">,</span><span class="n">singlecell_unique_clusterid</span><span class="p">]</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;sct_singlecell_barcode_id&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">singlecell_sct_barcode_id</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;sct_spatial_barcode_id&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">spatialcell_sct_barcode_id</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;annotation_spatial_barcode_id&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">annotation_spatial_barcode_id</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;annotation_spatial_celltypename&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">annotation_spatial_celltypename</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;annotation_spatial_cluster_id&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">annotation_spatial_cluster_id</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;lsp&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">spatialcell_unique_clustername</span><span class="p">,</span> <span class="n">spatialcell_unique_clusterid</span><span class="p">]</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;savepath&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">previous</span><span class="o">.</span><span class="n">savepath</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;KNN&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">previous</span><span class="o">.</span><span class="n">KNN</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;k_dist&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;k_dist&#39;</span><span class="p">]</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;k_index&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;k_index&#39;</span><span class="p">]</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;ad_sp&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">previous</span><span class="o">.</span><span class="n">ad_sp</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;fmnn&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">previous</span><span class="o">.</span><span class="n">fmnn</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;spatial_deg_annotation_output_clustername&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">spatial_deg_annotation_output_clustername</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;spatial_deg_annotation_output_celltypename&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">spatial_deg_annotation_output_celltypename</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;across_spatial_clusters_dispersion_cutoff&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">across_spatial_clusters_dispersion_cutoff</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;number_of_iteration_to_perform_celltype_annotations&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">number_of_iteration_to_perform_celltype_annotations</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;resolved_tie_issue_with_weighted_nearest_neighbor&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">resolved_tie_issue_with_weighted_nearest_neighbor</span>

    <span class="nb">input</span><span class="o">=</span><span class="n">SimpleNamespace</span><span class="p">(</span><span class="o">**</span><span class="n">inputvar</span><span class="p">)</span>
    <span class="n">good_anchors</span><span class="p">,</span><span class="n">visualize_anchors</span><span class="o">=</span><span class="n">find_commnon_MNN</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="n">inputvar</span><span class="p">[</span><span class="s1">&#39;visualize_anchors&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">visualize_anchors</span>
    <span class="nb">input</span><span class="o">=</span><span class="n">SimpleNamespace</span><span class="p">(</span><span class="o">**</span><span class="n">inputvar</span><span class="p">)</span>



    <span class="n">chosenKNN</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">KNN</span>
    <span class="n">sp_leiden_barcode2cluid</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">sp_leiden_cluid2barcode</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_spatial_barcode_id</span><span class="p">)):</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_spatial_cluster_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_spatial_barcode_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sp_leiden_barcode2cluid</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="nb">id</span>
    <span class="n">resolutionClusterWise</span><span class="o">=</span><span class="n">sp_leiden_barcode2cluid</span>

    <span class="n">deg</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">read_dist_and_nodes_as_graph</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">k_dist</span><span class="p">,</span><span class="nb">input</span><span class="o">.</span><span class="n">k_index</span><span class="p">)</span>
    <span class="n">mnn</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">fname_mnn_anchors</span>

    <span class="n">index</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mnn</span><span class="p">)):</span>
        <span class="n">name</span><span class="o">=</span><span class="n">mnn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;#&#39;</span><span class="o">+</span><span class="n">mnn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">good_anchors</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">mnn</span><span class="o">=</span><span class="n">mnn</span><span class="p">[</span><span class="n">index</span><span class="p">,:]</span>

    <span class="n">sc_ctype_id</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sc_ctype_name</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">lsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


    <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_barcode_id</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_barcode_id</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_cluster_id</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">annotation_singlecell_cluster_id</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">sc_clusters</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
    <span class="n">sp_cell_identity</span><span class="o">=</span><span class="n">find_all_the_spatial_cells_mapped_to_single_cells</span><span class="p">(</span><span class="n">sc_ctype_id</span><span class="p">,</span><span class="n">sc_clusters</span><span class="p">,</span><span class="n">mnn</span><span class="p">,</span><span class="n">sc_ctype_name</span><span class="p">)</span>

    <span class="n">unique_mapped</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">confused</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">all_mapped</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sp_cell_identity</span><span class="p">:</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="n">a</span><span class="o">=</span><span class="n">sp_cell_identity</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1">#print(&#39;1&#39; , a)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
            <span class="n">name</span><span class="o">+=</span><span class="s1">&#39;_a#d_&#39;</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">unique_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t1</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">t2</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
                <span class="n">t1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">t2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">confused</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">t2</span>
            <span class="c1">#print(key,t1,t2)</span>
        <span class="n">all_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">name</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
        <span class="c1">#fw.write(key+&#39;\t&#39;+str(name)+&#39;\n&#39;)</span>

    <span class="c1">#print(&#39;unique mapped 1&#39;,len(unique_mapped))</span>
    <span class="c1">#fw=open(input.savepath+&#39;unique_mapped.dat&#39;,&#39;w&#39;)</span>
    <span class="c1">#for key in unique_mapped:</span>
    <span class="c1">#    fw.write(key+&#39;\t&#39;+&#39;0\n&#39;)</span>
    <span class="c1">#fw.close()</span>

    <span class="n">ad_sp</span><span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">ad_sp</span>
    <span class="n">cellname</span><span class="o">=</span><span class="n">ad_sp</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">genename</span><span class="o">=</span><span class="n">ad_sp</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>


    <span class="c1">#saveunique_mapped=unique_mapped</span>
    <span class="c1">#unique_mapped=saveunique_mapped</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">resolved_tie_issue_with_weighted_nearest_neighbor</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;No&#39;</span><span class="p">:</span>
        <span class="n">all_anchored_mapped</span><span class="o">=</span><span class="n">resolved_confused_and_unmapped_mapping_of_cells_with_majority_vote</span><span class="p">(</span><span class="n">confused</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">all_mapped</span><span class="p">,</span><span class="n">unique_mapped</span><span class="p">,</span><span class="n">resolutionClusterWise</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_anchored_mapped</span><span class="o">=</span><span class="n">resolved_confused_and_unmapped_mapping_of_cells_with_weighted_average_of_inverse_distance_in_neighbors</span><span class="p">(</span><span class="n">confused</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">all_mapped</span><span class="p">,</span><span class="n">unique_mapped</span><span class="p">,</span><span class="n">resolutionClusterWise</span><span class="p">)</span>
    <span class="c1">#print(&#39;unique mapped 2&#39;,len(all_anchored_mapped))</span>
    <span class="n">availabled_anchors_mapped</span><span class="o">=</span><span class="n">all_anchored_mapped</span>

    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">number_of_iteration_to_perform_celltype_annotations</span><span class="p">):</span>
            <span class="n">unmapped_cellname</span><span class="p">,</span><span class="n">unmapped_deg</span><span class="o">=</span><span class="n">find_unmapped_cells_and_deg</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span><span class="n">availabled_anchors_mapped</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">resolved_tie_issue_with_weighted_nearest_neighbor</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;No&#39;</span><span class="p">:</span>
                <span class="n">unique_mapped</span><span class="o">=</span><span class="n">resolved_confused_and_unmapped_mapping_of_cells_with_majority_vote</span><span class="p">(</span><span class="n">unmapped_cellname</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">availabled_anchors_mapped</span><span class="p">,</span><span class="n">availabled_anchors_mapped</span><span class="p">,</span><span class="n">resolutionClusterWise</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_mapped</span><span class="o">=</span><span class="n">resolved_confused_and_unmapped_mapping_of_cells_with_weighted_average_of_inverse_distance_in_neighbors</span><span class="p">(</span><span class="n">unmapped_cellname</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">availabled_anchors_mapped</span><span class="p">,</span><span class="n">availabled_anchors_mapped</span><span class="p">,</span><span class="n">resolutionClusterWise</span><span class="p">)</span>

            <span class="c1">#print(&#39;iter&#39;,iter,len(unique_mapped),len(unmapped_cellname),len(unmapped_deg))</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellname</span><span class="p">)):</span>
                <span class="n">key</span><span class="o">=</span><span class="n">cellname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_mapped</span><span class="p">:</span>
                    <span class="n">unique_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;NM&#39;</span>

            <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">availabled_anchors_mapped</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">unique_mapped</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unique_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;NM&#39;</span><span class="p">:</span>
                    <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">availabled_anchors_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">unique_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1">#print(&#39;Iter&#39;,iter,count)</span>

            <span class="n">deg_annot_cluster_fname</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">savepath</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">input</span><span class="o">.</span><span class="n">spatial_deg_annotation_output_clustername</span>
            <span class="n">deg_annot_ct_fname</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">savepath</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">input</span><span class="o">.</span><span class="n">spatial_deg_annotation_output_celltypename</span>

            <span class="n">write_annotation</span><span class="p">(</span><span class="n">deg_annot_cluster_fname</span><span class="p">,</span><span class="n">deg_annot_ct_fname</span><span class="p">,</span><span class="n">unique_mapped</span><span class="p">,</span><span class="n">cellname</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">input</span></div>



<div class="viewcode-block" id="read_dist_and_nodes_as_graph">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.read_dist_and_nodes_as_graph">[docs]</a>
<span class="k">def</span> <span class="nf">read_dist_and_nodes_as_graph</span><span class="p">(</span><span class="n">knn_dist</span><span class="p">,</span><span class="n">knn_nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The helper function used in nico_based_annotation reads the edges information from k nearest neighbors data that convert into graph G, nodes, and degree.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">weights</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">knn_nodes</span><span class="p">)):</span>
        <span class="n">l</span><span class="o">=</span><span class="n">knn_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">dist</span><span class="o">=</span><span class="n">knn_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1">#print(l,dist)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
            <span class="n">temp</span><span class="o">=</span><span class="nb">sorted</span><span class="p">([</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;#&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>


    <span class="n">all_edges</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
        <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span>
        <span class="n">all_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


    <span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">all_edges</span><span class="p">)</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span>

    <span class="n">deg</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">:</span>
        <span class="n">deg</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">d</span>

    <span class="k">return</span> <span class="n">deg</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">weights</span></div>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def read_KNN_file(KNNfilename):</span>

<span class="sd">    f=open(KNNfilename)</span>
<span class="sd">    neighbors=[]</span>
<span class="sd">    for line in f:</span>
<span class="sd">        l=line[0:-1].split(&#39;,&#39;)</span>
<span class="sd">        neighbors.append(l[0:-1])</span>
<span class="sd">    edges=[]</span>
<span class="sd">    all_edges=[]</span>
<span class="sd">    d={}</span>
<span class="sd">    for j in range(len(neighbors)):</span>
<span class="sd">    #for j in range(1):</span>
<span class="sd">        l=neighbors[j]</span>
<span class="sd">        #for m in range(len(l)):</span>
<span class="sd">        for n in range(1,len(l)):</span>
<span class="sd">            temp=sorted([l[0],l[n]])</span>
<span class="sd">            name=temp[0]+&#39;#&#39;+temp[1]</span>
<span class="sd">            d[name]=1</span>

<span class="sd">            #all_edges.append([l[0].replace(&#39;cell&#39;,&#39;&#39;),l[n].replace(&#39;cell&#39;,&#39;&#39;)])</span>
<span class="sd">    for key in d:</span>
<span class="sd">        name=key.split(&#39;#&#39;)</span>
<span class="sd">        #print(key,name)</span>
<span class="sd">        all_edges.append(name)</span>


<span class="sd">    G=nx.Graph()</span>
<span class="sd">    G.add_edges_from(all_edges)</span>
<span class="sd">    deg = [d for (v, d) in G.degree()]</span>
<span class="sd">    nodes = [v for (v, d) in G.degree()]</span>

<span class="sd">    deg={}</span>
<span class="sd">    for (n,d) in G.degree:</span>
<span class="sd">        deg[n]=d</span>

<span class="sd">    return deg,G</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="return_singlecells">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.return_singlecells">[docs]</a>
<span class="k">def</span> <span class="nf">return_singlecells</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">,</span><span class="n">midzone</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The helper function used in find_all_the_spatial_cells_mapped_to_single_cells to find the scRNAseq cells belonging to specific cell types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">barcode_id</span><span class="o">=</span> <span class="n">cluster_data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cluster_id</span><span class="o">=</span> <span class="n">cluster_data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_id</span><span class="o">==</span><span class="n">midzone</span><span class="p">)</span>
    <span class="n">midzoneCells</span><span class="o">=</span><span class="n">barcode_id</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">midzoneCells</span><span class="p">)</span></div>




<div class="viewcode-block" id="findSpatialCells">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.findSpatialCells">[docs]</a>
<span class="k">def</span> <span class="nf">findSpatialCells</span><span class="p">(</span><span class="n">midzoneCells</span><span class="p">,</span><span class="n">mnn</span><span class="p">):</span>
    <span class="s2">&quot;The helper function is used in find_all_the_spatial_cells_mapped_to_single_cells to find the anchored cells for each cell type.&quot;</span>
    <span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">midzoneCells</span><span class="p">)):</span>
        <span class="n">first</span><span class="o">=</span><span class="n">midzoneCells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mnn</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">first</span><span class="p">)</span>
        <span class="n">spcells</span><span class="o">=</span><span class="n">mnn</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(spcells)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spcells</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">spcells</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">spcells</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">spcells</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">d</span></div>



<div class="viewcode-block" id="find_all_the_spatial_cells_mapped_to_single_cells">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.find_all_the_spatial_cells_mapped_to_single_cells">[docs]</a>
<span class="k">def</span> <span class="nf">find_all_the_spatial_cells_mapped_to_single_cells</span><span class="p">(</span><span class="n">sc_ctype_id</span><span class="p">,</span><span class="n">sc_clusters</span><span class="p">,</span><span class="n">mnn</span><span class="p">,</span><span class="n">sc_ctype_name</span><span class="p">):</span>
    <span class="s2">&quot;The helper function is used in nico_based_annotation to find the mapping of cells from both modalities.&quot;</span>
    <span class="n">spdata</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1"># single cell cluster id sc_ctype_id</span>
    <span class="c1"># single cell cluster name sc_ctype_name</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sc_ctype_id</span><span class="p">)):</span>
        <span class="n">sc_ct_specific_cells</span><span class="o">=</span><span class="n">return_singlecells</span><span class="p">(</span><span class="n">sc_clusters</span><span class="p">,</span><span class="n">sc_ctype_id</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># all the single cell barcode id of sc_ctype_name[i]</span>
        <span class="n">sp_ct_specific_cells</span><span class="o">=</span><span class="n">findSpatialCells</span><span class="p">(</span><span class="n">sc_ct_specific_cells</span><span class="p">,</span><span class="n">mnn</span><span class="p">)</span>
        <span class="c1">#print(&#39;1&#39;,i,sc_ctype_id[i],len(sp_ct_specific_cells))</span>
        <span class="n">spdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_ct_specific_cells</span><span class="p">)</span>
        <span class="c1">#print(sc_ctype_name[i], &#39;\tSC&#39;,len(sc_ct_specific_cells),&#39;\tSP&#39;,len(sp_ct_specific_cells))</span>

    <span class="n">sp_cell_identity</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sc_ctype_id</span><span class="p">)):</span>
        <span class="n">a</span><span class="o">=</span><span class="n">spdata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># this is dictionary</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_cell_identity</span><span class="p">:</span>
                <span class="n">sp_cell_identity</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="p">[[</span><span class="n">sc_ctype_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">name</span><span class="p">]]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sp_cell_identity</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sc_ctype_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">name</span><span class="p">]])</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sp_cell_identity</span><span class="p">:</span>
        <span class="n">a</span><span class="o">=</span><span class="n">sp_cell_identity</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1">#print(a)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#print(key, a)</span>
            <span class="n">t1</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">t2</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
                <span class="n">t1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">t2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">t1</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">&gt;</span><span class="n">t1</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">b</span><span class="o">=</span><span class="p">[[</span><span class="n">t2</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">t1</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]]</span>
                <span class="n">sp_cell_identity</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">b</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        a=list(spdata[i])</span>
<span class="sd">        for j in range(len(a)):</span>
<span class="sd">            name=a[j]</span>
<span class="sd">            if name not in sp_cell_identity:</span>
<span class="sd">                sp_cell_identity[name]=[sc_ctype_name[i]]</span>
<span class="sd">            else:</span>
<span class="sd">                sp_cell_identity[name].append(sc_ctype_name[i])</span>
<span class="sd">        &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">sp_cell_identity</span></div>


<div class="viewcode-block" id="write_annotation">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.write_annotation">[docs]</a>
<span class="k">def</span> <span class="nf">write_annotation</span><span class="p">(</span><span class="n">deg_annot_cluster_fname</span><span class="p">,</span><span class="n">deg_annot_ct_fname</span><span class="p">,</span><span class="n">unique_mapped</span><span class="p">,</span><span class="n">cellname</span><span class="p">):</span>
    <span class="s2">&quot;The helper function used in nico_based_annotation to generates each iteration&#39;s annotation cluster and cell type name CSV files.&quot;</span>
    <span class="n">sc_ctype_name</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">d2</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">unique_mapped</span><span class="p">:</span>
        <span class="n">a</span><span class="o">=</span><span class="n">unique_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d2</span><span class="p">:</span>
            <span class="n">d2</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d2</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sc_ctype_name</span><span class="p">:</span>
            <span class="n">sc_ctype_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1">#print(sc_ctype_name)</span>
    <span class="c1">#print(d.keys())</span>
    <span class="n">sc_ctype_name</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">sc_ctype_name</span><span class="p">)</span>
    <span class="n">fw</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">deg_annot_ct_fname</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;clusterID,clusterName,Frequency</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sc_ctype_name</span><span class="p">)):</span>
        <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="o">+</span><span class="n">sc_ctype_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">sc_ctype_name</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="n">sc_ctype_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span>
    <span class="n">fw</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1">#keys=sorted(list(unique_mapped.keys()))</span>
    <span class="n">fw</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">deg_annot_cluster_fname</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;barcode,mnn_based_annot</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellname</span><span class="p">)):</span>
        <span class="n">barcodeid</span><span class="o">=</span><span class="n">cellname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ctname</span><span class="o">=</span><span class="n">unique_mapped</span><span class="p">[</span><span class="n">barcodeid</span><span class="p">]</span>
        <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">barcodeid</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">ctname</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">fw</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>




<div class="viewcode-block" id="find_unmapped_cells_and_deg">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.find_unmapped_cells_and_deg">[docs]</a>
<span class="k">def</span> <span class="nf">find_unmapped_cells_and_deg</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span><span class="n">unique_mapped</span><span class="p">):</span>
    <span class="s2">&quot;Helper function for nico_based_annotation to find the unmapped non-anchored cells.&quot;</span>
    <span class="n">un_mapped_nodes</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">un_mapped_deg</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">deg</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_mapped</span><span class="p">:</span>
            <span class="n">un_mapped_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">un_mapped_deg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deg</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>

    <span class="n">un_mapped_deg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">un_mapped_deg</span><span class="p">)</span>
    <span class="n">un_mapped_nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">un_mapped_nodes</span><span class="p">)</span>
    <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">un_mapped_deg</span><span class="p">)</span>

    <span class="n">cellname</span><span class="o">=</span><span class="n">un_mapped_nodes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">degvalue</span><span class="o">=</span><span class="n">un_mapped_deg</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cellname</span><span class="p">,</span><span class="n">degvalue</span></div>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def resolved_confused_and_unmapped_mapping_of_cells_distance(confused,G,all_mapped):</span>
<span class="sd">    for mainkey in confused:</span>
<span class="sd">            a=G[mainkey]</span>
<span class="sd">            t=[]</span>
<span class="sd">            t1=[]</span>
<span class="sd">            for key in a:</span>
<span class="sd">                if key in all_mapped:</span>
<span class="sd">                    t.append(a[key][&#39;weight&#39;])</span>
<span class="sd">                    t1.append(key)</span>
<span class="sd">            t=np.array(t)</span>
<span class="sd">            t1=np.array(t1)</span>
<span class="sd">            ind=np.argsort(t)</span>
<span class="sd">            #print(&#39;4&#39;,len(t),t[ind])</span>

<span class="sd">            if len(t)&gt;0:</span>
<span class="sd">                key=t1[ind[0]]</span>
<span class="sd">                t=[all_mapped[key]]</span>
<span class="sd">                t1=[]</span>
<span class="sd">                t2=[]</span>
<span class="sd">                t3=[]</span>
<span class="sd">                t4=[]</span>
<span class="sd">                for i in range(len(t)):</span>
<span class="sd">                    t1.append(t[i][2])</span>
<span class="sd">                    t2.append(t[i][0])</span>
<span class="sd">                    t3.append(t[i][1])</span>
<span class="sd">                    t4.append(t[i][3])</span>
<span class="sd">                ind=np.argsort(np.array(t1))</span>
<span class="sd">                finalone=[t2[ind[0]], t3[ind[0]],    t1[ind[0]] , t4[ind[0]]      ]</span>
<span class="sd">            else:</span>
<span class="sd">                finalone=[&#39;NM&#39;, -1,  99999999, &#39;Null&#39;  ]</span>
<span class="sd">            #print(&#39;6&#39;,finalone1)</span>

<span class="sd">            all_mapped[mainkey]=finalone</span>

<span class="sd">    return all_mapped</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="resolved_confused_and_unmapped_mapping_of_cells_with_weighted_average_of_inverse_distance_in_neighbors">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.resolved_confused_and_unmapped_mapping_of_cells_with_weighted_average_of_inverse_distance_in_neighbors">[docs]</a>
<span class="k">def</span> <span class="nf">resolved_confused_and_unmapped_mapping_of_cells_with_weighted_average_of_inverse_distance_in_neighbors</span><span class="p">(</span><span class="n">confused</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">all_mapped</span><span class="p">,</span><span class="n">unique_mapped</span><span class="p">,</span><span class="n">sp_leiden_barcode2cluid_resolution_wise</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This helper function is used for nico_based_annotation to annotate confused anchored and non-anchored spatial cells using weighted average scores from the neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">mainkey</span> <span class="ow">in</span> <span class="n">confused</span><span class="p">:</span>
            <span class="n">a</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">mainkey</span><span class="p">]</span>
            <span class="c1">#print(&#39;\n\n\n\n&#39;,mainkey,len(a))</span>
            <span class="n">current_clu_id</span><span class="o">=</span><span class="n">sp_leiden_barcode2cluid_resolution_wise</span><span class="p">[</span><span class="n">mainkey</span><span class="p">]</span>
            <span class="n">x</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">t</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">weight_score</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_mapped</span><span class="p">:</span>
                    <span class="n">A</span><span class="o">=</span><span class="nb">sorted</span><span class="p">([</span><span class="n">mainkey</span><span class="p">,</span><span class="n">key</span><span class="p">])</span>
                    <span class="n">weight_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">weights</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;#&#39;</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="c1">#inverse of distance</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">current_clu_id</span><span class="o">==</span><span class="n">sp_leiden_barcode2cluid_resolution_wise</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="c1">#x.append(sp_leiden_barcode2cluid_resolution_wise[key])</span>
                        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

            <span class="n">weighted_avg_score</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">weighted_avg_score</span><span class="p">:</span>
                    <span class="n">weighted_avg_score</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="p">[</span><span class="n">weight_score</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weighted_avg_score</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight_score</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># are added</span>


            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">neigh_clu_id</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">#     Counter(x)</span>
                <span class="n">c</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">totalsum</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="c1">#print(&#39;a&#39;,mainkey,len(t),c,totalsum)#confused[mainkey])</span>
                <span class="c1">#print(&#39;b&#39;,current_clu_id,neigh_clu_id)</span>
                <span class="n">low2high</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
                <span class="n">high2low</span><span class="o">=</span><span class="n">low2high</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ws</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">tws</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_score</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">high2low</span><span class="p">:</span>
                    <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weighted_avg_score</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">/</span><span class="n">tws</span><span class="p">)</span> <span class="c1">#weighted average</span>


                <span class="n">t1</span><span class="o">=</span><span class="p">[]</span> <span class="c1">#integer number to denote the degree for the negihboring cells who has similar cell type</span>
                <span class="n">t2</span><span class="o">=</span><span class="p">[]</span> <span class="c1">#corresponding cell type name for from t1</span>
                <span class="n">t3</span><span class="o">=</span><span class="p">[]</span> <span class="c1">#weighted score (inverse of distance)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">high2low</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">high2low</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;_a#d_&#39;</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">t1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">high2low</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                        <span class="n">t2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">high2low</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">t3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">t1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">t1</span><span class="p">)</span>

                <span class="n">finalone</span><span class="o">=</span><span class="s1">&#39;NM&#39;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)):</span>
                    <span class="n">localdeg</span><span class="o">=</span><span class="n">t1</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">localctname</span><span class="o">=</span><span class="n">t2</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">temp</span><span class="o">=</span><span class="p">[]</span>
                    <span class="c1">#This step checks cell type (highest degree to lowest) from neighbors to see whether they belong to the same guiding cluster or not</span>
                    <span class="c1">#only if the cell type of the majority of neighbors and current cell (confused or unresolved) are in the same guiding cluster will it be assigned to this cell type</span>
                    <span class="k">if</span> <span class="n">localctname</span> <span class="ow">in</span> <span class="n">neigh_clu_id</span><span class="p">:</span>
                        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localctname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">finalone</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">break</span>


                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">finalone</span><span class="o">=</span><span class="s1">&#39;NM&#39;</span><span class="c1"># If no neighbor is found then it assigned to &#39;NM&#39;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">finalone</span><span class="o">==</span><span class="s1">&#39;NM&#39;</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">finalone</span><span class="o">=</span><span class="s1">&#39;xxxx&#39;</span> <span class="c1">#If you see this in the final annotation it means something is wrong</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">finalone</span><span class="o">=</span><span class="n">t2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#If neighbors belong to only one cell type then it assigned to that</span>
                    <span class="k">elif</span> <span class="n">t1</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">&gt;=</span><span class="n">t1</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span> <span class="c1">#If neighbors belong to many cell type (the first one has largest degree)</span>
                        <span class="k">if</span> <span class="n">t3</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">&lt;</span><span class="n">t3</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span> <span class="c1">#Here it preference for the normalized inverse distance score</span>
                            <span class="n">finalone</span><span class="o">=</span><span class="n">t2</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1">#if the second cell type has lower degree than first but it has higher weight score then it choses the second cell type</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">finalone</span><span class="o">=</span><span class="n">t2</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1">#if the second cell type has lower degree than first but it has lower weight score then it choses the first cell type</span>


                    <span class="c1">#print(&#39;b&#39;,current_clu_id,neigh_clu_id)</span>
                    <span class="c1">#print(&#39;index&#39;,index,t1[index])</span>
                    <span class="c1">#print(&#39;ok&#39;,high2low,c,ws)</span>
                    <span class="c1">#print(&#39;xx&#39;,neigh_clu_id,temp,finalone1)</span>

                <span class="c1">#print(&#39;final&#39;,finalone)</span>
                <span class="n">unique_mapped</span><span class="p">[</span><span class="n">mainkey</span><span class="p">]</span><span class="o">=</span><span class="n">finalone</span>
    <span class="k">return</span> <span class="n">unique_mapped</span></div>





<div class="viewcode-block" id="resolved_confused_and_unmapped_mapping_of_cells_with_majority_vote">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.resolved_confused_and_unmapped_mapping_of_cells_with_majority_vote">[docs]</a>
<span class="k">def</span> <span class="nf">resolved_confused_and_unmapped_mapping_of_cells_with_majority_vote</span><span class="p">(</span><span class="n">confused</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">all_mapped</span><span class="p">,</span><span class="n">unique_mapped</span><span class="p">,</span><span class="n">sp_leiden_barcode2cluid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This helper function is used for nico_based_annotation to annotate confused anchored and non-anchored spatial cells using a majority vote scheme from the neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">mainkey</span> <span class="ow">in</span> <span class="n">confused</span><span class="p">:</span>
            <span class="n">a</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">mainkey</span><span class="p">]</span>
            <span class="n">current_clu_id</span><span class="o">=</span><span class="n">sp_leiden_barcode2cluid</span><span class="p">[</span><span class="n">mainkey</span><span class="p">]</span>
            <span class="n">x</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">t</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_mapped</span><span class="p">:</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">current_clu_id</span><span class="o">==</span><span class="n">sp_leiden_barcode2cluid</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_mapped</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>


            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">neigh_clu_id</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">#     Counter(x)</span>
                <span class="n">c</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">totalsum</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">low2high</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
                <span class="n">high2low</span><span class="o">=</span><span class="n">low2high</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">t2</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">t1</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">high2low</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">high2low</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;_a#d_&#39;</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">t1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">high2low</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="c1">#integer number to denote the degree for the negihboring cells who has similar cell type</span>
                        <span class="n">t2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">high2low</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">#corresponding cell type name for from t1</span>
                <span class="n">t1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">t1</span><span class="p">)</span>

                <span class="n">finalone</span><span class="o">=</span><span class="s1">&#39;NM&#39;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)):</span>
                    <span class="n">localdeg</span><span class="o">=</span><span class="n">t1</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">localctname</span><span class="o">=</span><span class="n">t2</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="c1">#This step checks cell type (highest degree to lowest) from neighbors to see whether they belong to the same guiding cluster or not</span>
                    <span class="c1">#only if the cell type of the majority of neighbors and current cell (confused or unresolved) are in the same guiding cluster will it be assigned to this cell type</span>
                    <span class="n">temp</span><span class="o">=</span><span class="p">[]</span>
                    <span class="k">if</span> <span class="n">localctname</span> <span class="ow">in</span> <span class="n">neigh_clu_id</span><span class="p">:</span>
                        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localctname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">finalone</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">finalone</span><span class="o">=</span><span class="s1">&#39;NM&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">finalone</span><span class="o">=</span><span class="n">finalone</span><span class="c1">#t2[index]</span>

                <span class="n">unique_mapped</span><span class="p">[</span><span class="n">mainkey</span><span class="p">]</span><span class="o">=</span><span class="n">finalone</span>

    <span class="k">return</span> <span class="n">unique_mapped</span></div>



<div class="viewcode-block" id="visualize_umap_and_cell_coordinates_with_all_celltypes">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.visualize_umap_and_cell_coordinates_with_all_celltypes">[docs]</a>
<span class="k">def</span> <span class="nf">visualize_umap_and_cell_coordinates_with_all_celltypes</span><span class="p">(</span><span class="n">quepath</span><span class="o">=</span><span class="s1">&#39;./inputQuery/&#39;</span><span class="p">,</span><span class="n">positionFilename</span><span class="o">=</span><span class="s1">&#39;./inputQuery/tissue_positions_list.csv&#39;</span><span class="p">,</span>
<span class="n">number_of_iteration_to_perform_celltype_annotations</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">),</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">6</span><span class="p">)):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inputs:</span>

<span class="sd">    | Queried path for single-cell resolution of spatial data. This directory contains an expression matrix in scTransform-like normalization in the common gene space (&#39;sct_spatial.h5ad&#39;).</span>
<span class="sd">    | (default) quepath=&#39;./inputQuery/&#39;</span>

<span class="sd">    | Save the figures in PDF or PNG format (dpi for PNG format is 300)</span>
<span class="sd">    | (default) saveas=&#39;pdf&#39;</span>

<span class="sd">    | The position filename of cell coordinates</span>
<span class="sd">    | (default) positionFilename=&#39;./inputQuery/tissue_positions_list.csv&#39;</span>

<span class="sd">    | The number of iterations performed in the annotations</span>
<span class="sd">    | (default) number_of_iteration_to_perform_celltype_annotations=3</span>

<span class="sd">    | Colormap used to color the cell types</span>
<span class="sd">    | cmap=plt.cm.get_cmap(&#39;jet&#39;)</span>

<span class="sd">    | Background color in the figures</span>
<span class="sd">    | (default) transparent_mode=&#39;False&#39;</span>

<span class="sd">    | Dimension of the figure size.</span>
<span class="sd">    | (default) figsize=(15,6)</span>

<span class="sd">    Outputs:</span>

<span class="sd">    The annotation figure will be saved in &#39;./inputQuery/MNN_based_annotations/tissue_and_umap_with_all_celltype_annotations*</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">deg_annot_cluster_fname</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">number_of_iteration_to_perform_celltype_annotations</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_nico_annotation_cluster.csv&#39;</span>
    <span class="n">deg_annot_ct_fname</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">number_of_iteration_to_perform_celltype_annotations</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_nico_annotation_ct_name.csv&#39;</span>
    <span class="n">fig_save_path</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span>

    <span class="n">df_cluster</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">deg_annot_cluster_fname</span><span class="p">)</span>
    <span class="n">degbased_cluster</span><span class="o">=</span><span class="n">df_cluster</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">deg_annot_ct_fname</span><span class="p">)</span>
    <span class="n">degbased_ctname</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>


    <span class="n">adata</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;sct_spatial.h5ad&#39;</span><span class="p">)</span>
    <span class="n">temp</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_umap&#39;</span><span class="p">]</span>
    <span class="n">cellname</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="c1">#df.index.to_numpy()</span>
    <span class="n">cellname</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cellname</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellname</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">umap_not_order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cellname</span><span class="p">,</span><span class="n">temp</span><span class="p">))</span>
    <span class="c1">#sometime if you have less number of spatial cells (due to filtering step) in the analysis than the position coordinate have</span>
    <span class="c1">#then need to find correct pairing.</span>
    <span class="n">umap_data</span><span class="o">=</span><span class="n">sort_index_in_right_order</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">,</span><span class="n">umap_not_order</span><span class="p">)</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">positionFilename</span><span class="p">)</span>
    <span class="n">posdata_not_order</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">posdata</span><span class="o">=</span><span class="n">sort_index_in_right_order</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">,</span><span class="n">posdata_not_order</span><span class="p">)</span>

    <span class="n">points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">posdata</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">location_cellname2int</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">location_int2cellname</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">posdata</span><span class="p">)):</span>
        <span class="n">name</span><span class="o">=</span><span class="n">posdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">location_cellname2int</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
        <span class="n">location_int2cellname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">name</span>
        <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">posdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">posdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>

    <span class="n">cellsinCT</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">)):</span>
        <span class="nb">id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#celltype[degbased_cluster[i][0]]=id</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cellsinCT</span><span class="p">:</span>
            <span class="n">cellsinCT</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">=</span><span class="p">[</span> <span class="n">location_cellname2int</span><span class="p">[</span> <span class="n">degbased_cluster</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cellsinCT</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location_cellname2int</span><span class="p">[</span> <span class="n">degbased_cluster</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>


    <span class="n">CTname</span><span class="o">=</span><span class="n">degbased_ctname</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">fig</span><span class="p">,(</span><span class="n">ax</span><span class="p">)</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">plot_all_ct</span><span class="p">(</span><span class="n">CTname</span><span class="p">,</span><span class="n">points</span><span class="p">,</span><span class="n">cellsinCT</span><span class="p">,</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="kc">False</span><span class="p">,</span><span class="n">cmap</span><span class="p">)</span>
    <span class="n">plot_all_ct</span><span class="p">(</span><span class="n">CTname</span><span class="p">,</span><span class="n">umap_data</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span><span class="n">cellsinCT</span><span class="p">,</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="kc">True</span><span class="p">,</span><span class="n">cmap</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">,</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.50</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="n">ncol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">prop</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span><span class="mi">10</span><span class="p">},</span><span class="n">fancybox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
    <span class="c1">#plt.gca().axes.get_yaxis().set_visible(False)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

    <span class="c1">#fig.tight_layout()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="n">fig_save_path</span><span class="o">+</span><span class="s1">&#39;tissue_and_umap_with_all_celltype_annotations.&#39;</span><span class="o">+</span><span class="n">saveas</span> <span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fig_save_path</span><span class="o">+</span><span class="s1">&#39;tissue_and_umap_with_all_celltype_annotations.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="visualize_umap_and_cell_coordinates_with_selected_celltypes">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.visualize_umap_and_cell_coordinates_with_selected_celltypes">[docs]</a>
<span class="k">def</span> <span class="nf">visualize_umap_and_cell_coordinates_with_selected_celltypes</span><span class="p">(</span><span class="n">quepath</span><span class="o">=</span><span class="s1">&#39;./inputQuery/&#39;</span><span class="p">,</span><span class="n">positionFilename</span><span class="o">=</span><span class="s1">&#39;./inputQuery/tissue_positions_list.csv&#39;</span><span class="p">,</span>
<span class="n">number_of_iteration_to_perform_celltype_annotations</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">choose_celltypes</span><span class="o">=</span><span class="p">[],</span><span class="n">msna</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">showit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">),</span><span class="n">saveas</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span><span class="n">transparent_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mf">3.5</span><span class="p">)):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inputs:</span>

<span class="sd">    | Queried path for single-cell resolution of spatial data. This directory contains an expression matrix in scTransform-like normalization in the common gene space (&#39;sct_spatial.h5ad&#39;).</span>
<span class="sd">    | (default) quepath=&#39;./inputQuery/&#39;</span>

<span class="sd">    | The cell type pairs that you want to visualize as annotations</span>
<span class="sd">    | (default) choose_celltypes=[]</span>
<span class="sd">    | If the list is empty, the output will show for each cell type independently.</span>

<span class="sd">    | The position filename of cell coordinates</span>
<span class="sd">    | (default) positionFilename=&#39;./inputQuery/tissue_positions_list.csv&#39;</span>

<span class="sd">    | The number of iterations performed in the annotations</span>
<span class="sd">    | (default) number_of_iteration_to_perform_celltype_annotations=3</span>

<span class="sd">    | The marker size of chosen and NA cell types</span>
<span class="sd">    | (default) ms=0.5  (chosen)</span>
<span class="sd">    | (default) msna=0.1 (NA)</span>

<span class="sd">    | Colormap used to color the cell types</span>
<span class="sd">    | cmap=plt.cm.get_cmap(&#39;jet&#39;)</span>

<span class="sd">    | Save the figures in PDF or PNG format (dpi for PNG format is 300)</span>
<span class="sd">    | (default) saveas=&#39;pdf&#39;</span>

<span class="sd">    | Background color in the figures</span>
<span class="sd">    | (default) transparent_mode=&#39;False&#39;</span>

<span class="sd">    | Dimension of the figure size.</span>
<span class="sd">    | (default) figsize=(8,3.5)</span>

<span class="sd">    Outputs:</span>

<span class="sd">    The individual celltype annotation figure will be saved in &#39;./inputQuery/MNN_based_annotations/fig_individual_annotation&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">deg_annot_cluster_fname</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">number_of_iteration_to_perform_celltype_annotations</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_nico_annotation_cluster.csv&#39;</span>
    <span class="n">deg_annot_ct_fname</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">number_of_iteration_to_perform_celltype_annotations</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_nico_annotation_ct_name.csv&#39;</span>
    <span class="n">fig_save_path</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span>

    <span class="n">df_cluster</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">deg_annot_cluster_fname</span><span class="p">)</span>
    <span class="n">degbased_cluster</span><span class="o">=</span><span class="n">df_cluster</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">deg_annot_ct_fname</span><span class="p">)</span>
    <span class="n">degbased_ctname</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">choose_celltypes</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">mycluster_interest_all</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degbased_ctname</span><span class="p">)):</span>
            <span class="n">CC_celltype_name</span><span class="o">=</span><span class="n">degbased_ctname</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mycluster_interest_all</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">CC_celltype_name</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mycluster_interest_all</span><span class="o">=</span><span class="n">choose_celltypes</span>


    <span class="n">adata</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;sct_spatial.h5ad&#39;</span><span class="p">)</span>
    <span class="n">temp</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_umap&#39;</span><span class="p">]</span>
    <span class="n">cellname</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="c1">#df.index.to_numpy()</span>
    <span class="n">cellname</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cellname</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellname</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">umap_not_order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cellname</span><span class="p">,</span><span class="n">temp</span><span class="p">))</span>
    <span class="c1">#sometime if you have less number of spatial cells (due to filtering step) in the analysis than the position coordinate have</span>
    <span class="c1">#then need to find correct pairing.</span>
    <span class="n">umap_data</span><span class="o">=</span><span class="n">sort_index_in_right_order</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">,</span><span class="n">umap_not_order</span><span class="p">)</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">positionFilename</span><span class="p">)</span>
    <span class="n">posdata_not_order</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">posdata</span><span class="o">=</span><span class="n">sort_index_in_right_order</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">,</span><span class="n">posdata_not_order</span><span class="p">)</span>

    <span class="c1">#print(&#39;posdata&#39;,posdata_not_order.shape,posdata.shape)</span>
    <span class="c1">#print(&#39;umapdata&#39;,umap_not_order.shape,umap_data.shape)</span>

    <span class="n">mycluster_interest_id</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mycluster_interest_all</span><span class="p">)):</span>
        <span class="n">temp</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mycluster_interest_all</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degbased_ctname</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">degbased_ctname</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">mycluster_interest_all</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">degbased_ctname</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mycluster_interest_id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>


    <span class="n">CTname</span><span class="o">=</span><span class="n">degbased_ctname</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">fig_save_path</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span><span class="o">+</span><span class="s1">&#39;fig_individual_annotation/&#39;</span>
    <span class="n">create_directory</span><span class="p">(</span><span class="n">fig_save_path</span><span class="p">)</span>
    <span class="n">fig_save_path_leg</span><span class="o">=</span><span class="n">quepath</span><span class="o">+</span><span class="s1">&#39;MNN_based_annotations/&#39;</span><span class="o">+</span><span class="s1">&#39;fig_individual_annotation/&#39;</span><span class="o">+</span><span class="s1">&#39;leg/&#39;</span>
    <span class="n">create_directory</span><span class="p">(</span><span class="n">fig_save_path_leg</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mycluster_interest_all</span><span class="p">)):</span>
        <span class="n">CC_celltype_name</span><span class="o">=</span><span class="n">degbased_ctname</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
        <span class="n">mycluster_interest</span><span class="o">=</span><span class="n">mycluster_interest_all</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span>

        <span class="n">barcode</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mycluster_interest</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degbased_ctname</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">degbased_ctname</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">mycluster_interest</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">myindex</span><span class="o">=</span><span class="n">degbased_ctname</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">myindex</span><span class="p">)</span>
            <span class="n">barcode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">])</span>


        <span class="n">points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">posdata</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">location_cellname2int</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">location_int2cellname</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">posdata</span><span class="p">)):</span>
            <span class="n">name</span><span class="o">=</span><span class="n">posdata</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">location_cellname2int</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">j</span>
            <span class="n">location_int2cellname</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">name</span>
            <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">posdata</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">posdata</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>

        <span class="n">index</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">barcode</span><span class="p">)):</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mycluster_interest_id</span><span class="p">[</span><span class="n">fi</span><span class="p">])):</span>
            <span class="c1">#print(i,&#39;ankit&#39;,mycluster_interest_id[i])</span>
            <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">mycluster_interest_id</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">cellsinCT</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">)):</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">degbased_cluster</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1">#celltype[degbased_cluster[i][0]]=id</span>
            <span class="k">if</span> <span class="nb">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cellsinCT</span><span class="p">:</span>
                <span class="n">cellsinCT</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">=</span><span class="p">[</span> <span class="n">location_cellname2int</span><span class="p">[</span> <span class="n">degbased_cluster</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cellsinCT</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location_cellname2int</span><span class="p">[</span> <span class="n">degbased_cluster</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>



        <span class="c1">#=find_id(degbased_ctname,mycluster_interest,degbased_cluster)</span>
        <span class="c1">#PP2,id2,cellsinCT2=reading_data(posdata,cl2,degbased_cluster,mycluster_interest_id[i])</span>
        <span class="n">cl2</span><span class="o">=</span><span class="n">barcode</span>
        <span class="n">PP2</span><span class="o">=</span><span class="n">points</span>
        <span class="n">id2</span><span class="o">=</span><span class="n">index</span>



        <span class="n">fig</span><span class="p">,(</span><span class="n">ax</span><span class="p">)</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">plot_specific_ct</span><span class="p">(</span><span class="n">mycluster_interest</span><span class="p">,</span><span class="n">PP2</span><span class="p">,</span><span class="n">id2</span><span class="p">,</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cmap</span><span class="p">,</span><span class="n">ms</span><span class="p">,</span><span class="n">msna</span><span class="p">)</span>
        <span class="n">plot_specific_ct</span><span class="p">(</span><span class="n">mycluster_interest</span><span class="p">,</span><span class="n">umap_data</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span><span class="n">id2</span><span class="p">,</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cmap</span><span class="p">,</span><span class="n">ms</span><span class="p">,</span><span class="n">msna</span><span class="p">)</span>

        <span class="n">leg1</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">,</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.50</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="n">ncol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">prop</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span><span class="mi">8</span><span class="p">},</span><span class="n">fancybox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">shadow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="c1">#plt.gca().axes.get_yaxis().set_visible(False)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">filename</span><span class="o">=</span><span class="n">fig_save_path</span><span class="o">+</span><span class="n">remove_extra_character_from_name</span><span class="p">(</span><span class="n">mycluster_interest</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The figures are saved: &quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

        <span class="n">fig</span>  <span class="o">=</span> <span class="n">leg1</span><span class="o">.</span><span class="n">figure</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="n">bbox</span>  <span class="o">=</span> <span class="n">leg1</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
        <span class="n">filename</span><span class="o">=</span><span class="n">fig_save_path_leg</span><span class="o">+</span><span class="n">remove_extra_character_from_name</span><span class="p">(</span><span class="n">mycluster_interest</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;_leg&#39;</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">saveas</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="n">transparent_mode</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">showit</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>





<div class="viewcode-block" id="remove_extra_character_from_name">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.remove_extra_character_from_name">[docs]</a>
<span class="k">def</span> <span class="nf">remove_extra_character_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function remove the special characters from the cell type names so it should not throw error while saving the figures.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">name</span></div>



<div class="viewcode-block" id="plot_all_ct">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.plot_all_ct">[docs]</a>
<span class="k">def</span> <span class="nf">plot_all_ct</span><span class="p">(</span><span class="n">CTname</span><span class="p">,</span><span class="n">PP</span><span class="p">,</span><span class="n">cellsinCT</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="n">flag</span><span class="p">,</span><span class="n">cmap</span><span class="p">):</span>
    <span class="s2">&quot;Helper function used in visualizing cell type annotations to plot all cell types together.&quot;</span>
    <span class="c1">#cmap=plt.cm.get_cmap(&#39;Spectral&#39;)</span>
    <span class="c1">#cmap=plt.cm.get_cmap(&#39;jet&#39;)</span>

    <span class="n">cumsum</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">CTname</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">CTname</span><span class="p">)):</span>
        <span class="n">index</span><span class="o">=</span><span class="n">cellsinCT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">labelname</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="n">CTname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="n">rgba</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">cumsum</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">PP</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">PP</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">labelname</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">,</span><span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">PP</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">PP</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_specific_ct">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.plot_specific_ct">[docs]</a>
<span class="k">def</span> <span class="nf">plot_specific_ct</span><span class="p">(</span><span class="n">CTname</span><span class="p">,</span><span class="n">PP</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">ms</span><span class="p">,</span><span class="n">msna</span><span class="p">):</span>
    <span class="s2">&quot;Helper function used in visualizing cell type annotations to plot individual cell types.&quot;</span>
    <span class="n">cumsum</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">CTname</span><span class="p">))</span>
    <span class="n">remaining_index</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">PP</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">remaining_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">PP</span><span class="p">[</span><span class="n">remaining_index</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">PP</span><span class="p">[</span><span class="n">remaining_index</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;0.5&quot;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;NA&#39;</span><span class="p">,</span><span class="n">markersize</span><span class="o">=</span><span class="n">msna</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)):</span>
        <span class="n">labelname</span><span class="o">=</span><span class="n">CTname</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>  <span class="c1">#str(j)+&#39;-&#39;+</span>
        <span class="c1">#labelname=str(j)+&#39;-&#39;+CTname[j]</span>
        <span class="n">rgba</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">cumsum</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">PP</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span><span class="n">PP</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">labelname</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">rgba</span><span class="p">,</span><span class="n">markersize</span><span class="o">=</span><span class="n">ms</span><span class="p">)</span>
        <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">PP</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">PP</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="mi">1</span><span class="p">])</span></div>

        <span class="c1">#ax.text(x,y,str(j),fontsize=12)</span>

<div class="viewcode-block" id="sort_index_in_right_order">
<a class="viewcode-back" href="../../nico_annotations.html#nico_annotations.Annotations.sort_index_in_right_order">[docs]</a>
<span class="k">def</span> <span class="nf">sort_index_in_right_order</span><span class="p">(</span><span class="n">correct</span><span class="p">,</span><span class="n">wrong</span><span class="p">):</span>
    <span class="s2">&quot;Helper function used in visualize cell type annotations.&quot;</span>
    <span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wrong</span><span class="p">)):</span>
        <span class="n">d</span><span class="p">[</span><span class="n">wrong</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">i</span>
    <span class="n">index</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correct</span><span class="p">)):</span>
        <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">correct</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">right</span><span class="o">=</span><span class="n">wrong</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">right</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Grün lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>