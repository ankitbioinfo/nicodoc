<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>nico_annotations.utils.pyliger_utilities &mdash; NiCo 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=8d563738"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            NiCo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NiCo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">nico_annotations.utils.pyliger_utilities</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for nico_annotations.utils.pyliger_utilities</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">nla</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">sla</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span><span class="p">,</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span>
<span class="c1">#from ._utilities import _h5_idx_generator</span>


<div class="viewcode-block" id="NMF_obj_eval">
<a class="viewcode-back" href="../../../nico_annotations.utils.html#nico_annotations.utils.pyliger_utilities.NMF_obj_eval">[docs]</a>
<span class="k">def</span> <span class="nf">NMF_obj_eval</span><span class="p">(</span><span class="n">Xs</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">Hs</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Sp</span><span class="p">,</span> <span class="n">Vs</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="s2">&quot;Evaluates NMF objective function (sparsity, Vs optional).&quot;</span>
    <span class="k">if</span> <span class="n">Vs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Vs</span> <span class="o">=</span> <span class="p">[</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Xs</span><span class="p">))]</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Vs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Xs</span><span class="p">))])</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">Xs</span><span class="p">)</span>
    <span class="n">pen</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Vs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Xs</span><span class="p">))])</span>
    <span class="n">spars</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">Sp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spars</span> <span class="o">=</span> <span class="n">Sp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Xs</span><span class="p">))])</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">+</span><span class="n">pen</span> <span class="o">+</span> <span class="n">spars</span></div>





<div class="viewcode-block" id="iNMF">
<a class="viewcode-back" href="../../../nico_annotations.utils.html#nico_annotations.utils.pyliger_utilities.iNMF">[docs]</a>
<span class="k">def</span> <span class="nf">iNMF</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span><span class="n">value_lambda</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span><span class="n">thresh</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span><span class="n">max_iters</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">nrep</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">H_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">V_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">rand_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">print_obj</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1">#&quot;Integrated NMF (sparsity optional).&quot;</span>
    <span class="c1">#Ms = [Xs[i].shape[1] for i in range(K)]</span>
    <span class="c1">#W_f = np.zeros((N, D))</span>
    <span class="c1">#Hs_f = [np.zeros((D, Ms[i])) for i in range(K)]</span>
    <span class="c1">#Vs_f = [np.zeros((N, D)) for i in range(K)]</span>
    <span class="c1"># used from pyliger codes optimize_ALS _iNMF_ANLS.py</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">num_genes</span>  <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

    <span class="n">best_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">Inf</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrep</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">rand_seed</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1">### 1. Initialization (W, V_i, H_i)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">num_genes</span><span class="p">)))</span>
        <span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">num_genes</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">ns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">k</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

        <span class="c1">#print(&#39;1b&#39;,k,N,ns,W.shape)</span>
        <span class="c1">#print(&#39;2a&#39;,H[0].shape,H[1].shape,V[0].shape,V[1].shape)</span>

        <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="k">if</span> <span class="n">V_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">V_init</span>

        <span class="k">if</span> <span class="n">H_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">H_init</span>

        <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">sqrt_lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">value_lambda</span><span class="p">)</span>

        <span class="c1"># Initial training obj</span>
        <span class="n">obj_train_approximation</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">obj_train_penalty</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="c1">#print(&#39;maxi&#39;,X[i].shape,H[i].shape,W.shape,V[i].shape)</span>
            <span class="n">obj_train_approximation</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">obj_train_penalty</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">obj0</span> <span class="o">=</span> <span class="n">obj_train_approximation</span> <span class="o">+</span> <span class="n">value_lambda</span> <span class="o">*</span> <span class="n">obj_train_penalty</span>

        <span class="c1">### 2. Iteration starts here</span>
        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">:</span>
                <span class="c1">## 1) update H matrix</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                    <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nnlsm_blockpivot</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(((</span><span class="n">W</span> <span class="o">+</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">sqrt_lambda</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
                                            <span class="n">B</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">num_genes</span><span class="p">))))</span><span class="o">.</span><span class="n">transpose</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

                <span class="c1">## 2) update V matrix</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                    <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nnlsm_blockpivot</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sqrt_lambda</span> <span class="o">*</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
                                            <span class="n">B</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(((</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">W</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">num_genes</span><span class="p">)))))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1">## 3) update W matrix</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">nnlsm_blockpivot</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="n">B</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">obj_train_prev</span> <span class="o">=</span> <span class="n">obj0</span>
                <span class="n">obj_train_approximation</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">obj_train_penalty</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                    <span class="n">obj_train_approximation</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="n">obj_train_penalty</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">obj0</span> <span class="o">=</span> <span class="n">obj_train_approximation</span> <span class="o">+</span> <span class="n">value_lambda</span> <span class="o">*</span> <span class="n">obj_train_penalty</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">obj_train_prev</span> <span class="o">-</span> <span class="n">obj0</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">obj_train_prev</span> <span class="o">+</span> <span class="n">obj0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1">#print(iter,delta,obj0)</span>

        <span class="k">if</span> <span class="n">obj0</span> <span class="o">&lt;</span> <span class="n">best_obj</span><span class="p">:</span>
            <span class="n">final_W</span> <span class="o">=</span> <span class="n">W</span>
            <span class="n">final_H</span> <span class="o">=</span> <span class="n">H</span>
            <span class="n">final_V</span> <span class="o">=</span> <span class="n">V</span>
            <span class="n">best_obj</span> <span class="o">=</span> <span class="n">obj0</span>
            <span class="n">best_seed</span> <span class="o">=</span> <span class="n">rand_seed</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">print_obj</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Objective: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_obj</span><span class="p">),</span><span class="nb">iter</span><span class="p">,</span><span class="n">delta</span><span class="p">)</span>

    <span class="c1">#liger_object.W = final_W.transpose()</span>

    <span class="c1">### 3. Save results into the liger_object</span>
    <span class="c1">#for i in range(N):</span>
        <span class="c1">#liger_object.adata_list[i].obsm[&#39;H&#39;] = final_H[i]</span>
        <span class="c1">#liger_object.adata_list[i].varm[&#39;W&#39;] = final_W.transpose()</span>
        <span class="c1">#liger_object.adata_list[i].varm[&#39;V&#39;] = final_V[i].transpose()</span>
        <span class="c1">#idx = liger_object.adata_list[i].uns[&#39;var_gene_idx&#39;]</span>
        <span class="c1">#shape = liger_object.adata_list[i].shape</span>
        <span class="c1">#save_W = np.zeros((shape[1], k))</span>
        <span class="c1">#save_W[idx, :] = final_W.transpose()</span>
        <span class="c1">#save_V = np.zeros((shape[1], k))</span>
        <span class="c1">#save_V[idx, :] = final_V[i].transpose()</span>
        <span class="c1">#liger_object.adata_list[i].obsm[&#39;H&#39;] = final_H[i]</span>
        <span class="c1">#liger_object.adata_list[i].varm[&#39;W&#39;] = save_W</span>
        <span class="c1">#liger_object.adata_list[i].varm[&#39;V&#39;] = save_V</span>
    <span class="k">return</span> <span class="n">final_H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">final_H</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">final_W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">final_V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">final_V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span></div>



<div class="viewcode-block" id="nonneg">
<a class="viewcode-back" href="../../../nico_annotations.utils.html#nico_annotations.utils.pyliger_utilities.nonneg">[docs]</a>
<span class="k">def</span> <span class="nf">nonneg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-16</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Given a input matrix, set all negative values to be zero &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span>
    <span class="k">return</span> <span class="n">x</span></div>



<span class="k">def</span> <span class="nf">_init_W</span><span class="p">(</span><span class="n">num_genes</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">rand_seed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper function to initialize a W matrix&quot;&quot;&quot;</span>
    <span class="c1"># set seed</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">rand_seed</span><span class="p">)</span>

    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">num_genes</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>

    <span class="c1"># normalize columns of dictionaries</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">W</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">W</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">W</span>


<span class="k">def</span> <span class="nf">_init_V</span><span class="p">(</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">Xs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper function to initialize a V matrix for in-memory mode&quot;&quot;&quot;</span>
    <span class="c1"># pick k sample from datasets as initial V matrix</span>
    <span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="n">Xs</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_cells</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)]</span>

    <span class="c1"># normalize columns of dictionaries</span>
    <span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">V</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def _init_V_online(num_cells, num_samples, k, Xs, chunk_size, rand_seed):</span>

<span class="sd">    np.random.seed(seed=rand_seed)</span>

<span class="sd">    Vs = []</span>
<span class="sd">    for i in range(num_samples):</span>
<span class="sd">        # pick k sample from datasets as initial H matrix</span>
<span class="sd">        idx = np.sort(np.random.choice(list(range(num_cells[i])), k))</span>
<span class="sd">        V = []</span>
<span class="sd">        for left, right in _h5_idx_generator(chunk_size, num_cells[i]):</span>
<span class="sd">            select_idx = idx[(idx &gt;= left) &amp; (idx &lt; right)] - left  # shift index because of handling chunk each time</span>
<span class="sd">            if select_idx.shape[0] &gt; 0:  # only load chunks whose indexes are picked</span>
<span class="sd">                X = Xs[i][&#39;scale_data&#39;][left:right]</span>
<span class="sd">                V.append(X[select_idx, :])</span>
<span class="sd">        V = sps.vstack(V).transpose().toarray()</span>

<span class="sd">        # normalize columns of dictionaries</span>
<span class="sd">        V = V / np.sqrt(np.sum(np.square(V), axis=0))</span>

<span class="sd">        Vs.append(V)</span>

<span class="sd">    return Vs</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_init_V_online</span><span class="p">(</span><span class="n">num_cell</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">rand_seed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper function to initialize a V matrix for online learning&quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">rand_seed</span><span class="p">)</span>

    <span class="c1"># pick k sample from datasets as initial H matrix</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_cell</span><span class="p">)),</span> <span class="n">k</span><span class="p">))</span>
    <span class="n">V</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">_h5_idx_generator</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">num_cell</span><span class="p">):</span>
        <span class="n">select_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)]</span> <span class="o">-</span> <span class="n">left</span>  <span class="c1"># shift index because of handling chunk each time</span>
        <span class="k">if</span> <span class="n">select_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># only load chunks whose indexes are picked</span>
            <span class="n">X_chunk</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="s1">&#39;scale_data&#39;</span><span class="p">][</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
            <span class="n">V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_chunk</span><span class="p">[</span><span class="n">select_idx</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

    <span class="c1"># normalize columns of dictionaries</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">V</span>


<span class="k">def</span> <span class="nf">_init_H</span><span class="p">(</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper function to initialize a H matrix&quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">H</span>

<span class="k">def</span> <span class="nf">_update_W_HALS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper function to update W matrix by HALS</span>
<span class="sd">    A = HiHi^t, B = XiHit, W = gene x k, V = [gene x k]&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">W_update_numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">W_update_denominator</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)):</span>
            <span class="n">W_update_numerator</span> <span class="o">=</span> <span class="n">W_update_numerator</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="p">((</span><span class="n">W</span> <span class="o">+</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">@</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">W_update_denominator</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">W</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonneg</span><span class="p">(</span><span class="n">W</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">W_update_numerator</span> <span class="o">/</span> <span class="n">W_update_denominator</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">W</span>


<span class="k">def</span> <span class="nf">_update_V_HALS</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">value_lambda</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper function to update V matrix by HALS</span>
<span class="sd">    A = HiHi^t, B = XiHit, W = gene x k, V = [gene x k]&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)):</span>
            <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonneg</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">value_lambda</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">@</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">value_lambda</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">V</span>


<span class="k">def</span> <span class="nf">_update_H_HALS</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">value_lambda</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper function to update H matrix by HALS&quot;&quot;&quot;</span>
    <span class="n">VitVi</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vi</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">@</span> <span class="n">Vi</span> <span class="k">for</span> <span class="n">Vi</span> <span class="ow">in</span> <span class="n">V</span><span class="p">]</span>
    <span class="n">W_Vi</span> <span class="o">=</span> <span class="p">[</span><span class="n">W</span> <span class="o">+</span> <span class="n">Vi</span> <span class="k">for</span> <span class="n">Vi</span> <span class="ow">in</span> <span class="n">V</span><span class="p">]</span>
    <span class="n">W_Vi_sq</span> <span class="o">=</span> <span class="p">[</span><span class="n">W_Vii</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">@</span> <span class="n">W_Vii</span> <span class="k">for</span> <span class="n">W_Vii</span> <span class="ow">in</span> <span class="n">W_Vi</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nonneg</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">W_Vi</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">@</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">W_Vi</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">@</span> <span class="n">W_Vi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">H</span><span class="p">[</span>
                <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">value_lambda</span> <span class="o">*</span> <span class="n">VitVi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                                        <span class="n">W_Vi_sq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">value_lambda</span> <span class="o">*</span> <span class="n">VitVi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">H</span>


<span class="c1">######use numba</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">#@jit(nopython=True)</span>
<span class="sd">def _update_W_HALS(A, B, W, V):</span>

<span class="sd">    for j in range(W.shape[1]):</span>
<span class="sd">        W_update_numerator = np.zeros(W.shape[0])</span>
<span class="sd">        W_update_denominator = 0.0</span>
<span class="sd">        for i in range(len(V)):</span>
<span class="sd">            W_update_numerator = W_update_numerator + B[i][:, j] - ((W + V[i]) @ A[i])[:, j]</span>
<span class="sd">            W_update_denominator += A[i][j, j]</span>
<span class="sd">        temp = W[:, j] + W_update_numerator / W_update_denominator</span>
<span class="sd">        temp[temp &lt; 1e-16] = 1e-16</span>
<span class="sd">        W[:, j] = temp</span>
<span class="sd">    return W</span>


<span class="sd">#@jit(nopython=True)</span>
<span class="sd">def _update_V_HALS(A, B, W, V, value_lambda):</span>

<span class="sd">    for j in range(V[0].shape[1]):</span>
<span class="sd">        for i in range(len(V)):</span>
<span class="sd">            temp = V[i][:, j] + (B[i][:, j] - (W + (1 + value_lambda) * V[i]) @ A[i][:, j]) / ((1 + value_lambda) * A[i][j, j])</span>
<span class="sd">            temp[temp &lt; 1e-16] = 1e-16</span>
<span class="sd">            V[i][:, j] = temp</span>

<span class="sd">    return V</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="nnlsm_blockpivot">
<a class="viewcode-back" href="../../../nico_annotations.utils.html#nico_annotations.utils.pyliger_utilities.nnlsm_blockpivot">[docs]</a>
<span class="k">def</span> <span class="nf">nnlsm_blockpivot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">is_input_prod</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Nonnegativity-constrained least squares with block principal pivoting method and column grouping</span>
<span class="sd">    Solves min ||AX-B||_2^2 s.t. X &gt;= 0 element-wise.</span>
<span class="sd">    J. Kim and H. Park, Fast nonnegative matrix factorization: An active-set-like method and comparisons,</span>
<span class="sd">    SIAM Journal on Scientific Computing,</span>
<span class="sd">    vol. 33, no. 6, pp. 3261-3281, 2011.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : numpy.array, shape (m,n)</span>
<span class="sd">    B : numpy.array or scipy.sparse matrix, shape (m,k)</span>
<span class="sd">    Optional Parameters</span>
<span class="sd">    -------------------</span>
<span class="sd">    is_input_prod : True/False. -  If True, the A and B arguments are interpreted as</span>
<span class="sd">            AtA and AtB, respectively. Default is False.</span>
<span class="sd">    init: numpy.array, shape (n,k). - If provided, init is used as an initial value for the algorithm.</span>
<span class="sd">            Default is None.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X, (success, Y, num_cholesky, num_eq, num_backup)</span>
<span class="sd">    X : numpy.array, shape (n,k) - solution</span>
<span class="sd">    success : True/False - True if the solution is found. False if the algorithm did not terminate</span>
<span class="sd">            due to numerical errors.</span>
<span class="sd">    Y : numpy.array, shape (n,k) - Y = A.T * A * X - A.T * B</span>
<span class="sd">    num_cholesky : int - the number of Cholesky factorizations needed</span>
<span class="sd">    num_eq : int - the number of linear systems of equations needed to be solved</span>
<span class="sd">    num_backup: int - the number of appearances of the back-up rule. See SISC paper for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_input_prod</span><span class="p">:</span>
        <span class="n">AtA</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">AtB</span> <span class="o">=</span> <span class="n">B</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">AtA</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sps</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
            <span class="n">AtB</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            <span class="n">AtB</span> <span class="o">=</span> <span class="n">AtB</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">AtB</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

    <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">AtB</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">MAX_ITER</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">5</span>

    <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">PassSet</span> <span class="o">=</span> <span class="n">init</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">num_cholesky</span><span class="p">,</span> <span class="n">num_eq</span> <span class="o">=</span> <span class="n">normal_eq_comb</span><span class="p">(</span><span class="n">AtA</span><span class="p">,</span> <span class="n">AtB</span><span class="p">,</span> <span class="n">PassSet</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">AtA</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">AtB</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="o">-</span><span class="n">AtB</span>
        <span class="n">PassSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">num_cholesky</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_eq</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">p_bar</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">p_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">k</span><span class="p">])</span>
    <span class="n">p_vec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">p_bar</span>
    <span class="n">ninf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">k</span><span class="p">])</span>
    <span class="n">ninf_vec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">not_opt_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="n">PassSet</span><span class="p">)</span>
    <span class="n">infea_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PassSet</span><span class="p">)</span>

    <span class="n">not_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_opt_set</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">infea_set</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">not_opt_colset</span> <span class="o">=</span> <span class="n">not_good</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">not_opt_cols</span> <span class="o">=</span> <span class="n">not_opt_colset</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">big_iter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num_backup</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">not_opt_cols</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">big_iter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">MAX_ITER</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">big_iter</span> <span class="o">&gt;</span> <span class="n">MAX_ITER</span><span class="p">:</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">break</span>

        <span class="n">cols_set1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">not_opt_colset</span><span class="p">,</span> <span class="n">not_good</span> <span class="o">&lt;</span> <span class="n">ninf_vec</span><span class="p">)</span>
        <span class="n">temp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">not_opt_colset</span><span class="p">,</span> <span class="n">not_good</span> <span class="o">&gt;=</span> <span class="n">ninf_vec</span><span class="p">)</span>
        <span class="n">temp2</span> <span class="o">=</span> <span class="n">p_vec</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="n">cols_set2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">temp1</span><span class="p">,</span> <span class="n">temp2</span><span class="p">)</span>
        <span class="n">cols_set3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">temp1</span><span class="p">,</span> <span class="o">~</span><span class="n">temp2</span><span class="p">)</span>

        <span class="n">cols1</span> <span class="o">=</span> <span class="n">cols_set1</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cols2</span> <span class="o">=</span> <span class="n">cols_set2</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cols3</span> <span class="o">=</span> <span class="n">cols_set3</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cols1</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p_vec</span><span class="p">[</span><span class="n">cols1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_bar</span>
            <span class="n">ninf_vec</span><span class="p">[</span><span class="n">cols1</span><span class="p">]</span> <span class="o">=</span> <span class="n">not_good</span><span class="p">[</span><span class="n">cols1</span><span class="p">]</span>
            <span class="n">true_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">not_opt_set</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">cols_set1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">false_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">infea_set</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">cols_set1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">PassSet</span><span class="p">[</span><span class="n">true_set</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">PassSet</span><span class="p">[</span><span class="n">false_set</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">cols2</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p_vec</span><span class="p">[</span><span class="n">cols2</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_vec</span><span class="p">[</span><span class="n">cols2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">temp_tile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">cols_set2</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">true_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">not_opt_set</span><span class="p">,</span> <span class="n">temp_tile</span><span class="p">)</span>
            <span class="n">false_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">infea_set</span><span class="p">,</span> <span class="n">temp_tile</span><span class="p">)</span>
            <span class="n">PassSet</span><span class="p">[</span><span class="n">true_set</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">PassSet</span><span class="p">[</span><span class="n">false_set</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">cols3</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols3</span><span class="p">:</span>
                <span class="n">candi_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                    <span class="n">not_opt_set</span><span class="p">[:,</span> <span class="n">col</span><span class="p">],</span> <span class="n">infea_set</span><span class="p">[:,</span> <span class="n">col</span><span class="p">])</span>
                <span class="n">to_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">candi_set</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">PassSet</span><span class="p">[</span><span class="n">to_change</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">PassSet</span><span class="p">[</span><span class="n">to_change</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
                <span class="n">num_backup</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">not_opt_cols</span><span class="p">],</span> <span class="n">temp_cholesky</span><span class="p">,</span> <span class="n">temp_eq</span><span class="p">)</span> <span class="o">=</span> <span class="n">normal_eq_comb</span><span class="p">(</span>
            <span class="n">AtA</span><span class="p">,</span> <span class="n">AtB</span><span class="p">[:,</span> <span class="n">not_opt_cols</span><span class="p">],</span> <span class="n">PassSet</span><span class="p">[:,</span> <span class="n">not_opt_cols</span><span class="p">])</span>
        <span class="n">num_cholesky</span> <span class="o">+=</span> <span class="n">temp_cholesky</span>
        <span class="n">num_eq</span> <span class="o">+=</span> <span class="n">temp_eq</span>
        <span class="n">X</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-16</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Y</span><span class="p">[:,</span> <span class="n">not_opt_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">AtA</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">not_opt_cols</span><span class="p">])</span> <span class="o">-</span> <span class="n">AtB</span><span class="p">[:,</span> <span class="n">not_opt_cols</span><span class="p">]</span>
        <span class="n">Y</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-16</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">not_opt_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">not_opt_colset</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">not_opt_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">not_opt_mask</span><span class="p">,</span> <span class="n">Y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="o">~</span><span class="n">PassSet</span><span class="p">)</span>
        <span class="n">infea_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">not_opt_mask</span><span class="p">,</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">PassSet</span><span class="p">)</span>
        <span class="n">not_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_opt_set</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">infea_set</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">not_opt_colset</span> <span class="o">=</span> <span class="n">not_good</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">not_opt_cols</span> <span class="o">=</span> <span class="n">not_opt_colset</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">success</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">num_cholesky</span><span class="p">,</span> <span class="n">num_eq</span><span class="p">,</span> <span class="n">num_backup</span><span class="p">)</span></div>



<div class="viewcode-block" id="normal_eq_comb">
<a class="viewcode-back" href="../../../nico_annotations.utils.html#nico_annotations.utils.pyliger_utilities.normal_eq_comb">[docs]</a>
<span class="k">def</span> <span class="nf">normal_eq_comb</span><span class="p">(</span><span class="n">AtA</span><span class="p">,</span> <span class="n">AtB</span><span class="p">,</span> <span class="n">PassSet</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Solve many systems of linear equations using combinatorial grouping.</span>
<span class="sd">    M. H. Van Benthem and M. R. Keenan, J. Chemometrics 2004; 18: 441-450</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    AtA : numpy.array, shape (n,n)</span>
<span class="sd">    AtB : numpy.array, shape (n,k)</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (Z,num_cholesky,num_eq)</span>
<span class="sd">    Z : numpy.array, shape (n,k) - solution</span>
<span class="sd">    num_cholesky : int - the number of unique cholesky decompositions done</span>
<span class="sd">    num_eq: int - the number of systems of linear equations solved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_cholesky</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num_eq</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">AtB</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([])</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">PassSet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">PassSet</span><span class="p">):</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">nla</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">AtA</span><span class="p">,</span> <span class="n">AtB</span><span class="p">)</span>
        <span class="n">num_cholesky</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">num_eq</span> <span class="o">=</span> <span class="n">AtB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">AtB</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PassSet</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">PassSet</span><span class="p">):</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="n">PassSet</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">nla</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">AtA</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">cols</span><span class="p">)],</span> <span class="n">AtB</span><span class="p">[</span><span class="n">cols</span><span class="p">])</span>
                <span class="n">num_cholesky</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">num_eq</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># Both _column_group_loop() and _column_group_recursive() work well.</span>
            <span class="c1"># Based on preliminary testing,</span>
            <span class="c1"># _column_group_loop() is slightly faster for tiny k(&lt;10), but</span>
            <span class="c1"># _column_group_recursive() is faster for large k&#39;s.</span>
            <span class="c1">#</span>
            <span class="n">grps</span> <span class="o">=</span> <span class="n">_column_group_recursive</span><span class="p">(</span><span class="n">PassSet</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">gr</span> <span class="ow">in</span> <span class="n">grps</span><span class="p">:</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="n">PassSet</span><span class="p">[:,</span> <span class="n">gr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cols</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">gr</span><span class="p">)</span>
                    <span class="n">ix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="c1"># scipy.linalg.cho_solve can be used instead of numpy.linalg.solve.</span>
                    <span class="c1"># For small n(&lt;200), numpy.linalg.solve appears faster, whereas</span>
                    <span class="c1"># for large n(&gt;500), scipy.linalg.cho_solve appears faster.</span>
                    <span class="c1"># Usage example of scipy.linalg.cho_solve:</span>
                    <span class="c1">#Z[ix1] = sla.cho_solve(sla.cho_factor(AtA[ix2]),AtB[ix1])</span>
                    <span class="c1">#</span>
                    <span class="n">Z</span><span class="p">[</span><span class="n">ix1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nla</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">AtA</span><span class="p">[</span><span class="n">ix2</span><span class="p">],</span> <span class="n">AtB</span><span class="p">[</span><span class="n">ix1</span><span class="p">])</span>
                    <span class="n">num_cholesky</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">num_eq</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>
                    <span class="n">num_eq</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Z</span><span class="p">,</span> <span class="n">num_cholesky</span><span class="p">,</span> <span class="n">num_eq</span></div>



<span class="k">def</span> <span class="nf">_column_group_recursive</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Given a binary matrix, find groups of the same columns</span>
<span class="sd">        with a recursive strategy</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    B : numpy.array, True/False in each element</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A list of arrays - each array contain indices of columns that are the same.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">column_group_sub</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">initial</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="column_group_sub">
<a class="viewcode-back" href="../../../nico_annotations.utils.html#nico_annotations.utils.pyliger_utilities.column_group_sub">[docs]</a>
<span class="k">def</span> <span class="nf">column_group_sub</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cols</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">cols</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">col_trues</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">vec</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">col_falses</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[(</span><span class="o">~</span><span class="n">vec</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">col_trues</span><span class="p">,</span> <span class="n">col_falses</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">col_trues</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">vec</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">col_falses</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[(</span><span class="o">~</span><span class="n">vec</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">column_group_sub</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col_trues</span><span class="p">)</span>
        <span class="n">after</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">column_group_sub</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col_falses</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">after</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Grn lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>